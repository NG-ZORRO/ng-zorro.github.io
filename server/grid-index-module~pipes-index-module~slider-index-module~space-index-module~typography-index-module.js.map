{"version":3,"sources":["./publish/__ivy_ngcc__/fesm2015/ng-zorro-antd-slider.js"],"names":[],"mappings":";;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACuC;AACrB;AACgI;AAC9I;AAC4G;AACvH;AACkD;AACd;AAC7B;;AAE/C;AACA;AACA;AACA;AACwC;AACQ;AACN;AACM;;AAEhD;AACA;AACA,+DAA+D;AAC/D,IAAI,uDAAgB;AACpB,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,wDAAiB;AACrB,CAAC;AACD,iEAAiE;AACjE,IAAI,uDAAgB;AACpB,CAAC;AACD;AACA,mBAAmB,2DAAoB;AACvC,IAAI,wDAAiB;AACrB,CAAC;AACD,gEAAgE;AAChE,IAAI,uDAAgB;AACpB,CAAC;AACD,mBAAmB,2DAAoB;AACvC,IAAI,wDAAiB;AACrB,CAAC;AACD,0DAA0D;AAC1D,IAAI,uDAAgB;AACpB,CAAC;AACD;AACA,IAAI,yDAAkB;AACtB,IAAI,wDAAiB,uDAAuD,4DAAqB;AACjG,CAAC;AACD,yDAAyD;AACzD,IAAI,uDAAgB;AACpB,CAAC;AACD;AACA,IAAI,yDAAkB;AACtB,IAAI,wDAAiB;AACrB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qCAAqC;AACjG;AACA,wBAAwB,gEAAyB,EAAE,wDAAwD;;AAE3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAiD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,WAAW;AACtG;AACA;AACA;AACA,0CAA0C,QAAQ,qFAAqF,EAAE;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,2CAA2C,+DAAwB,mBAAmB,+DAAwB,CAAC,+DAAwB,GAAG;AACtN;AACA,+BAA+B,+DAAwB,EAAE,+HAA+H;AACxL,QAAQ,yDAAkB;AAC1B,QAAQ,yDAAkB,CAAC,wEAAkB;AAC7C,KAAK;AACL;AACA,QAAQ,4DAAqB,MAAM,yDAAkB;AACrD,QAAQ,4DAAqB,MAAM,yDAAkB;AACrD,KAAK,EAAE,wEAAwE;AAC/E,QAAQ,wDAAiB,iFAAiF,0BAA0B,EAAE,kFAAkF,0BAA0B,EAAE;AACpP,KAAK,EAAE,WAAW,6MAA6M,2CAA2C,kEAA2B,qPAAqP;AAC1hB,QAAQ,uDAAgB;AACxB,KAAK;AACL,QAAQ,wDAAiB;AACzB,KAAK,EAAE,eAAe,wEAAyB,EAAE,uDAAc,yCAAyC;AACxG;AACA,KAAK,wBAAwB;AAC7B,KAAK,OAAO,+DAAiB;AAC7B;AACA;AACA,gBAAgB,OAAO,uDAAS,oBAAoB,gBAAgB,IAAI;AACxE,eAAe,OAAO,uDAAS,SAAS,wEAAkB,GAAG,gBAAgB,IAAI;AACjF,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,eAAe,OAAO,mDAAK,EAAE;AAC7B,cAAc,OAAO,mDAAK,EAAE;AAC5B,aAAa,OAAO,mDAAK,EAAE;AAC3B,sBAAsB,OAAO,mDAAK,EAAE;AACpC,wBAAwB,OAAO,mDAAK,EAAE;AACtC,wBAAwB,OAAO,mDAAK,EAAE;AACtC,cAAc,OAAO,mDAAK,EAAE;AAC5B;AACA,wDAAU;AACV,IAAI,4EAAY;AAChB,IAAI,wDAAU;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA,0CAA0C;AAC1C,sBAAsB,8BAA8B;AACpD,0BAA0B;AAC1B,+BAA+B;AAC/B,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAW,aAAa,8DAAQ;AACpE,oCAAoC,gEAAU,aAAa,gEAAU;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mFAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAA8D;AACjF,mCAAmC,sDAAS,wBAAwB,6DAAM,cAAc,0DAAG,CAAC,mEAAW,GAAG,4DAAK,eAAe,0DAAG;AACjI,0BAA0B,sDAAS;AACnC,mCAAmC,sDAAS,sBAAsB,6DAAM,cAAc,0DAAG,CAAC,mEAAW,GAAG,4DAAK,eAAe,2EAAoB,IAAI,0DAAG,iDAAiD,2EAAoB,IAAI,gEAAS;AACzO,SAAS;AACT,0BAA0B,kDAAK;AAC/B,yBAAyB,kDAAK;AAC9B,wBAAwB,kDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mFAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,4EAAY;AACpF;AACA;AACA,eAAe,0EAAU;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,gFAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mFAAmB;AACtD,kBAAkB,mFAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4DAA4D;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,qCAAqC,+DAAwB,mBAAmB,+DAAwB,CAAC,+DAAwB,GAAG,+DAAwB,CAAC,8DAAe,GAAG;AAC/O;AACA,yBAAyB,+DAAwB,EAAE,4GAA4G;AAC/J,QAAQ,+DAAwB;AAChC,QAAQ,yDAAkB;AAC1B,KAAK;AACL;AACA,QAAQ,4DAAqB,MAAM,yDAAkB;AACrD,QAAQ,4DAAqB,MAAM,yDAAkB;AACrD,KAAK,EAAE,kEAAkE;AACzE,QAAQ,wDAAiB,2EAA2E,8BAA8B,EAAE;AACpI,KAAK,EAAE,WAAW,uWAAuW,YAAY,qCAAqC,qCAAqC,gEAAyB;AACxe;AACA,yBAAyB,gEAAiB;AAC1C,6BAA6B,gEAAU;AACvC;AACA,aAAa;AACb;AACA,YAAY,kEAA2B,2xBAA2xB;AACl0B,QAAQ,4DAAqB;AAC7B,QAAQ,uDAAgB;AACxB,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,QAAQ,wDAAiB;AACzB,QAAQ,wDAAiB;AACzB,QAAQ,0DAAmB;AAC3B,KAAK;AACL,QAAQ,yDAAkB;AAC1B,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,KAAK,EAAE,2BAA2B,iCAAiC,oDAAW,EAAE,uDAAc,0EAA0E,EAAE,wCAAwC;AAClN;AACA,KAAK,wBAAwB;AAC7B,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,8DAAQ;AACpB;AACA;AACA,cAAc,OAAO,uDAAS,oBAAoB,eAAe,IAAI;AACrE,yBAAyB,OAAO,0DAAY,oCAAoC;AAChF,kBAAkB,OAAO,mDAAK,EAAE;AAChC,cAAc,OAAO,mDAAK,EAAE;AAC5B,kBAAkB,OAAO,mDAAK,EAAE;AAChC,eAAe,OAAO,mDAAK,EAAE;AAC7B,kBAAkB,OAAO,mDAAK,EAAE;AAChC,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,sBAAsB,OAAO,mDAAK,EAAE;AACpC,eAAe,OAAO,mDAAK,EAAE;AAC7B,aAAa,OAAO,mDAAK,EAAE;AAC3B,aAAa,OAAO,mDAAK,EAAE;AAC3B,cAAc,OAAO,mDAAK,EAAE;AAC5B,wBAAwB,OAAO,mDAAK,EAAE;AACtC,0BAA0B,OAAO,mDAAK,EAAE;AACxC,sBAAsB,OAAO,mDAAK,EAAE;AACpC,uBAAuB,OAAO,oDAAM,EAAE;AACtC;AACA,wDAAU;AACV,IAAI,4EAAY;AAChB,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4EAAY;AAChB,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4EAAY;AAChB,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4EAAY;AAChB,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4EAAY;AAChB,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4EAAY;AAChB,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2EAAW;AACf,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2EAAW;AACf,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2EAAW;AACf,IAAI,wDAAU;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAA2C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2EAAW;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA,yBAAyB,mCAAmC;AAC5D;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0EAA0E,4CAA4C;AACtH;AACA,8BAA8B,+DAAwB,EAAE,0EAA0E,mJAAmJ,0CAA0C,kEAA2B,4SAA4S;AACtoB,QAAQ,4DAAqB;AAC7B,QAAQ,wDAAiB;AACzB,QAAQ,0DAAmB;AAC3B,KAAK;AACL,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,KAAK,EAAE,eAAe,uDAAc,EAAE,uDAAc,yCAAyC;AAC7F;AACA,kBAAkB,OAAO,mDAAK,EAAE;AAChC,kBAAkB,OAAO,mDAAK,EAAE;AA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","file":"grid-index-module~pipes-index-module~slider-index-module~space-index-module~typography-index-module.js","sourcesContent":["import { __decorate, __metadata } from 'tslib';\nimport { RIGHT_ARROW, UP_ARROW, LEFT_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Injectable, Component, ChangeDetectionStrategy, ViewEncapsulation, ChangeDetectorRef, ViewChild, Input, EventEmitter, forwardRef, ViewChildren, Output, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { InputBoolean, ensureNumberInRange, silentEvent, getPrecision, getPercent, getElementOffset, InputNumber, arraysEqual } from 'ng-zorro-antd/core/util';\nimport { fromEvent, merge } from 'rxjs';\nimport { filter, tap, pluck, map, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { NzTooltipDirective, NzToolTipModule } from 'ng-zorro-antd/tooltip';\nimport { CommonModule } from '@angular/common';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'ng-zorro-antd/tooltip';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@angular/cdk/platform';\n\nconst _c0 = [\"handle\"];\nconst _c1 = [\"slider\"];\nfunction NzSliderComponent_nz_slider_step_4_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"nz-slider-step\", 7);\n} if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"vertical\", ctx_r1.nzVertical)(\"lowerBound\", ctx_r1.bounds.lower)(\"upperBound\", ctx_r1.bounds.upper)(\"marksArray\", ctx_r1.marksArray)(\"included\", ctx_r1.nzIncluded);\n} }\nfunction NzSliderComponent_nz_slider_handle_5_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"nz-slider-handle\", 8);\n} if (rf & 2) {\n    const handle_r4 = ctx.$implicit;\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"vertical\", ctx_r2.nzVertical)(\"reverse\", ctx_r2.nzReverse)(\"offset\", handle_r4.offset)(\"value\", handle_r4.value)(\"active\", handle_r4.active)(\"tooltipFormatter\", ctx_r2.nzTipFormatter)(\"tooltipVisible\", ctx_r2.nzTooltipVisible)(\"tooltipPlacement\", ctx_r2.nzTooltipPlacement);\n} }\nfunction NzSliderComponent_nz_slider_marks_6_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"nz-slider-marks\", 9);\n} if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"vertical\", ctx_r3.nzVertical)(\"min\", ctx_r3.nzMin)(\"max\", ctx_r3.nzMax)(\"lowerBound\", ctx_r3.bounds.lower)(\"upperBound\", ctx_r3.bounds.upper)(\"marksArray\", ctx_r3.marksArray)(\"included\", ctx_r3.nzIncluded);\n} }\nfunction NzSliderMarksComponent_span_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 2);\n} if (rf & 2) {\n    const attr_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"ant-slider-mark-active\", attr_r1.active);\n    ɵngcc0.ɵɵproperty(\"ngStyle\", attr_r1.style)(\"innerHTML\", attr_r1.label, ɵngcc0.ɵɵsanitizeHtml);\n} }\nfunction NzSliderStepComponent_span_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 2);\n} if (rf & 2) {\n    const mark_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"ant-slider-dot-active\", mark_r1.active);\n    ɵngcc0.ɵɵproperty(\"ngStyle\", mark_r1.style);\n} }\nclass NzSliderService {\n    constructor() {\n        this.isDragging = false;\n    }\n}\n/** @nocollapse */\nNzSliderService.ɵfac = function NzSliderService_Factory(t) { return new (t || NzSliderService)(); };\n/** @nocollapse */\nNzSliderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NzSliderService, factory: NzSliderService.ɵfac });\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSliderHandleComponent {\n    constructor(sliderService, cdr) {\n        this.sliderService = sliderService;\n        this.cdr = cdr;\n        this.tooltipVisible = 'default';\n        this.active = false;\n        this.style = {};\n        this.enterHandle = () => {\n            if (!this.sliderService.isDragging) {\n                this.toggleTooltip(true);\n                this.updateTooltipPosition();\n                this.cdr.detectChanges();\n            }\n        };\n        this.leaveHandle = () => {\n            if (!this.sliderService.isDragging) {\n                this.toggleTooltip(false);\n                this.cdr.detectChanges();\n            }\n        };\n    }\n    ngOnChanges(changes) {\n        const { offset, value, active, tooltipVisible, reverse } = changes;\n        if (offset || reverse) {\n            this.updateStyle();\n        }\n        if (value) {\n            this.updateTooltipTitle();\n            this.updateTooltipPosition();\n        }\n        if (active) {\n            if (active.currentValue) {\n                this.toggleTooltip(true);\n            }\n            else {\n                this.toggleTooltip(false);\n            }\n        }\n        if ((tooltipVisible === null || tooltipVisible === void 0 ? void 0 : tooltipVisible.currentValue) === 'always') {\n            Promise.resolve().then(() => this.toggleTooltip(true, true));\n        }\n    }\n    focus() {\n        var _a;\n        (_a = this.handleEl) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();\n    }\n    toggleTooltip(show, force = false) {\n        var _a, _b;\n        if (!force && (this.tooltipVisible !== 'default' || !this.tooltip)) {\n            return;\n        }\n        if (show) {\n            (_a = this.tooltip) === null || _a === void 0 ? void 0 : _a.show();\n        }\n        else {\n            (_b = this.tooltip) === null || _b === void 0 ? void 0 : _b.hide();\n        }\n    }\n    updateTooltipTitle() {\n        this.tooltipTitle = this.tooltipFormatter ? this.tooltipFormatter(this.value) : `${this.value}`;\n    }\n    updateTooltipPosition() {\n        if (this.tooltip) {\n            Promise.resolve().then(() => { var _a; return (_a = this.tooltip) === null || _a === void 0 ? void 0 : _a.updatePosition(); });\n        }\n    }\n    updateStyle() {\n        const vertical = this.vertical;\n        const reverse = this.reverse;\n        const offset = this.offset;\n        const positionStyle = vertical\n            ? {\n                [reverse ? 'top' : 'bottom']: `${offset}%`,\n                [reverse ? 'bottom' : 'top']: 'auto',\n                transform: reverse ? null : `translateY(+50%)`\n            }\n            : {\n                [reverse ? 'right' : 'left']: `${offset}%`,\n                [reverse ? 'left' : 'right']: 'auto',\n                transform: `translateX(${reverse ? '+' : '-'}50%)`\n            };\n        this.style = positionStyle;\n        this.cdr.markForCheck();\n    }\n}\n/** @nocollapse */\nNzSliderHandleComponent.ɵfac = function NzSliderHandleComponent_Factory(t) { return new (t || NzSliderHandleComponent)(ɵngcc0.ɵɵdirectiveInject(NzSliderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };\n/** @nocollapse */\nNzSliderHandleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NzSliderHandleComponent, selectors: [[\"nz-slider-handle\"]], viewQuery: function NzSliderHandleComponent_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, true);\n        ɵngcc0.ɵɵviewQuery(NzTooltipDirective, true);\n    } if (rf & 2) {\n        var _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.handleEl = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltip = _t.first);\n    } }, hostBindings: function NzSliderHandleComponent_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mouseenter\", function NzSliderHandleComponent_mouseenter_HostBindingHandler() { return ctx.enterHandle(); })(\"mouseleave\", function NzSliderHandleComponent_mouseleave_HostBindingHandler() { return ctx.leaveHandle(); });\n    } }, inputs: { tooltipVisible: \"tooltipVisible\", active: \"active\", vertical: \"vertical\", reverse: \"reverse\", offset: \"offset\", value: \"value\", tooltipPlacement: \"tooltipPlacement\", tooltipFormatter: \"tooltipFormatter\" }, exportAs: [\"nzSliderHandle\"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 4, consts: [[\"tabindex\", \"0\", \"nz-tooltip\", \"\", 1, \"ant-slider-handle\", 3, \"ngStyle\", \"nzTooltipTitle\", \"nzTooltipTrigger\", \"nzTooltipPlacement\"], [\"handle\", \"\"]], template: function NzSliderHandleComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0, 1);\n    } if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.style)(\"nzTooltipTitle\", ctx.tooltipFormatter === null || ctx.tooltipVisible === \"never\" ? null : ctx.tooltipTitle)(\"nzTooltipTrigger\", null)(\"nzTooltipPlacement\", ctx.tooltipPlacement);\n    } }, directives: [ɵngcc1.NzTooltipDirective, ɵngcc2.NgStyle], encapsulation: 2, changeDetection: 0 });\nNzSliderHandleComponent.ctorParameters = () => [\n    { type: NzSliderService },\n    { type: ChangeDetectorRef }\n];\nNzSliderHandleComponent.propDecorators = {\n    handleEl: [{ type: ViewChild, args: ['handle', { static: false },] }],\n    tooltip: [{ type: ViewChild, args: [NzTooltipDirective, { static: false },] }],\n    vertical: [{ type: Input }],\n    reverse: [{ type: Input }],\n    offset: [{ type: Input }],\n    value: [{ type: Input }],\n    tooltipVisible: [{ type: Input }],\n    tooltipPlacement: [{ type: Input }],\n    tooltipFormatter: [{ type: Input }],\n    active: [{ type: Input }]\n};\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Object)\n], NzSliderHandleComponent.prototype, \"active\", void 0);\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSliderComponent {\n    constructor(sliderService, cdr, platform) {\n        this.sliderService = sliderService;\n        this.cdr = cdr;\n        this.platform = platform;\n        this.nzDisabled = false;\n        this.nzDots = false;\n        this.nzIncluded = true;\n        this.nzRange = false;\n        this.nzVertical = false;\n        this.nzReverse = false;\n        this.nzMarks = null;\n        this.nzMax = 100;\n        this.nzMin = 0;\n        this.nzStep = 1;\n        this.nzTooltipVisible = 'default';\n        this.nzTooltipPlacement = 'top';\n        this.nzOnAfterChange = new EventEmitter();\n        this.value = null;\n        this.cacheSliderStart = null;\n        this.cacheSliderLength = null;\n        this.activeValueIndex = undefined; // Current activated handle's index ONLY for range=true\n        this.track = { offset: null, length: null }; // Track's offset and length\n        this.handles = []; // Handles' offset\n        this.marksArray = null; // \"steps\" in array type with more data & FILTER out the invalid mark\n        this.bounds = { lower: null, upper: null }; // now for nz-slider-step\n    }\n    ngOnInit() {\n        this.handles = generateHandlers(this.nzRange ? 2 : 1);\n        this.marksArray = this.nzMarks ? this.generateMarkItems(this.nzMarks) : null;\n        this.bindDraggingHandlers();\n        this.toggleDragDisabled(this.nzDisabled);\n        if (this.getValue() === null) {\n            this.setValue(this.formatValue(null));\n        }\n    }\n    ngOnChanges(changes) {\n        const { nzDisabled, nzMarks, nzRange } = changes;\n        if (nzDisabled && !nzDisabled.firstChange) {\n            this.toggleDragDisabled(nzDisabled.currentValue);\n        }\n        else if (nzMarks && !nzMarks.firstChange) {\n            this.marksArray = this.nzMarks ? this.generateMarkItems(this.nzMarks) : null;\n        }\n        else if (nzRange && !nzRange.firstChange) {\n            this.setValue(this.formatValue(null));\n        }\n    }\n    ngOnDestroy() {\n        this.unsubscribeDrag();\n    }\n    writeValue(val) {\n        this.setValue(val, true);\n    }\n    onValueChange(_value) { }\n    onTouched() { }\n    registerOnChange(fn) {\n        this.onValueChange = fn;\n    }\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    setDisabledState(isDisabled) {\n        this.nzDisabled = isDisabled;\n        this.toggleDragDisabled(isDisabled);\n    }\n    /**\n     * Event handler is only triggered when a slider handler is focused.\n     */\n    onKeyDown(e) {\n        const code = e.keyCode;\n        const isIncrease = code === RIGHT_ARROW || code === UP_ARROW;\n        const isDecrease = code === LEFT_ARROW || code === DOWN_ARROW;\n        if (!(isIncrease || isDecrease)) {\n            return;\n        }\n        e.preventDefault();\n        const step = (isDecrease ? -this.nzStep : this.nzStep) * (this.nzReverse ? -1 : 1);\n        const newVal = this.nzRange ? this.value[this.activeValueIndex] + step : this.value + step;\n        this.setActiveValue(ensureNumberInRange(newVal, this.nzMin, this.nzMax));\n    }\n    setValue(value, isWriteValue = false) {\n        if (isWriteValue) {\n            this.value = this.formatValue(value);\n            this.updateTrackAndHandles();\n        }\n        else if (!valuesEqual(this.value, value)) {\n            this.value = value;\n            this.updateTrackAndHandles();\n            this.onValueChange(this.getValue(true));\n        }\n    }\n    getValue(cloneAndSort = false) {\n        if (cloneAndSort && this.value && isValueRange(this.value)) {\n            return [...this.value].sort((a, b) => a - b);\n        }\n        return this.value;\n    }\n    /**\n     * Clone & sort current value and convert them to offsets, then return the new one.\n     */\n    getValueToOffset(value) {\n        let normalizedValue = value;\n        if (typeof normalizedValue === 'undefined') {\n            normalizedValue = this.getValue(true);\n        }\n        return isValueRange(normalizedValue) ? normalizedValue.map(val => this.valueToOffset(val)) : this.valueToOffset(normalizedValue);\n    }\n    /**\n     * Find the closest value to be activated.\n     */\n    setActiveValueIndex(pointerValue) {\n        const value = this.getValue();\n        if (isValueRange(value)) {\n            let minimal = null;\n            let gap;\n            let activeIndex = -1;\n            value.forEach((val, index) => {\n                gap = Math.abs(pointerValue - val);\n                if (minimal === null || gap < minimal) {\n                    minimal = gap;\n                    activeIndex = index;\n                }\n            });\n            this.activeValueIndex = activeIndex;\n            this.handlerComponents.toArray()[activeIndex].focus();\n        }\n        else {\n            this.handlerComponents.toArray()[0].focus();\n        }\n    }\n    setActiveValue(pointerValue) {\n        if (isValueRange(this.value)) {\n            const newValue = [...this.value];\n            newValue[this.activeValueIndex] = pointerValue;\n            this.setValue(newValue);\n        }\n        else {\n            this.setValue(pointerValue);\n        }\n    }\n    /**\n     * Update track and handles' position and length.\n     */\n    updateTrackAndHandles() {\n        const value = this.getValue();\n        const offset = this.getValueToOffset(value);\n        const valueSorted = this.getValue(true);\n        const offsetSorted = this.getValueToOffset(valueSorted);\n        const boundParts = isValueRange(valueSorted) ? valueSorted : [0, valueSorted];\n        const trackParts = isValueRange(offsetSorted) ? [offsetSorted[0], offsetSorted[1] - offsetSorted[0]] : [0, offsetSorted];\n        this.handles.forEach((handle, index) => {\n            handle.offset = isValueRange(offset) ? offset[index] : offset;\n            handle.value = isValueRange(value) ? value[index] : value || 0;\n        });\n        [this.bounds.lower, this.bounds.upper] = boundParts;\n        [this.track.offset, this.track.length] = trackParts;\n        this.cdr.markForCheck();\n    }\n    onDragStart(value) {\n        this.toggleDragMoving(true);\n        this.cacheSliderProperty();\n        this.setActiveValueIndex(this.getLogicalValue(value));\n        this.setActiveValue(this.getLogicalValue(value));\n        this.showHandleTooltip(this.nzRange ? this.activeValueIndex : 0);\n    }\n    onDragMove(value) {\n        this.setActiveValue(this.getLogicalValue(value));\n        this.cdr.markForCheck();\n    }\n    getLogicalValue(value) {\n        return this.nzReverse ? this.nzMax - value + this.nzMin : value;\n    }\n    onDragEnd() {\n        this.nzOnAfterChange.emit(this.getValue(true));\n        this.toggleDragMoving(false);\n        this.cacheSliderProperty(true);\n        this.hideAllHandleTooltip();\n        this.cdr.markForCheck();\n    }\n    /**\n     * Create user interactions handles.\n     */\n    bindDraggingHandlers() {\n        if (!this.platform.isBrowser) {\n            return;\n        }\n        const sliderDOM = this.slider.nativeElement;\n        const orientField = this.nzVertical ? 'pageY' : 'pageX';\n        const mouse = {\n            start: 'mousedown',\n            move: 'mousemove',\n            end: 'mouseup',\n            pluckKey: [orientField]\n        };\n        const touch = {\n            start: 'touchstart',\n            move: 'touchmove',\n            end: 'touchend',\n            pluckKey: ['touches', '0', orientField],\n            filter: (e) => e instanceof TouchEvent\n        };\n        [mouse, touch].forEach(source => {\n            const { start, move, end, pluckKey, filter: filterFunc = () => true } = source;\n            source.startPlucked$ = fromEvent(sliderDOM, start).pipe(filter(filterFunc), tap(silentEvent), pluck(...pluckKey), map((position) => this.findClosestValue(position)));\n            source.end$ = fromEvent(document, end);\n            source.moveResolved$ = fromEvent(document, move).pipe(filter(filterFunc), tap(silentEvent), pluck(...pluckKey), distinctUntilChanged(), map((position) => this.findClosestValue(position)), distinctUntilChanged(), takeUntil(source.end$));\n        });\n        this.dragStart$ = merge(mouse.startPlucked$, touch.startPlucked$);\n        this.dragMove$ = merge(mouse.moveResolved$, touch.moveResolved$);\n        this.dragEnd$ = merge(mouse.end$, touch.end$);\n    }\n    subscribeDrag(periods = ['start', 'move', 'end']) {\n        if (periods.indexOf('start') !== -1 && this.dragStart$ && !this.dragStart_) {\n            this.dragStart_ = this.dragStart$.subscribe(this.onDragStart.bind(this));\n        }\n        if (periods.indexOf('move') !== -1 && this.dragMove$ && !this.dragMove_) {\n            this.dragMove_ = this.dragMove$.subscribe(this.onDragMove.bind(this));\n        }\n        if (periods.indexOf('end') !== -1 && this.dragEnd$ && !this.dragEnd_) {\n            this.dragEnd_ = this.dragEnd$.subscribe(this.onDragEnd.bind(this));\n        }\n    }\n    unsubscribeDrag(periods = ['start', 'move', 'end']) {\n        if (periods.indexOf('start') !== -1 && this.dragStart_) {\n            this.dragStart_.unsubscribe();\n            this.dragStart_ = null;\n        }\n        if (periods.indexOf('move') !== -1 && this.dragMove_) {\n            this.dragMove_.unsubscribe();\n            this.dragMove_ = null;\n        }\n        if (periods.indexOf('end') !== -1 && this.dragEnd_) {\n            this.dragEnd_.unsubscribe();\n            this.dragEnd_ = null;\n        }\n    }\n    toggleDragMoving(movable) {\n        const periods = ['move', 'end'];\n        if (movable) {\n            this.sliderService.isDragging = true;\n            this.subscribeDrag(periods);\n        }\n        else {\n            this.sliderService.isDragging = false;\n            this.unsubscribeDrag(periods);\n        }\n    }\n    toggleDragDisabled(disabled) {\n        if (disabled) {\n            this.unsubscribeDrag();\n        }\n        else {\n            this.subscribeDrag(['start']);\n        }\n    }\n    findClosestValue(position) {\n        const sliderStart = this.getSliderStartPosition();\n        const sliderLength = this.getSliderLength();\n        const ratio = ensureNumberInRange((position - sliderStart) / sliderLength, 0, 1);\n        const val = (this.nzMax - this.nzMin) * (this.nzVertical ? 1 - ratio : ratio) + this.nzMin;\n        const points = this.nzMarks === null\n            ? []\n            : Object.keys(this.nzMarks)\n                .map(parseFloat)\n                .sort((a, b) => a - b);\n        if (this.nzStep !== 0 && !this.nzDots) {\n            const closestOne = Math.round(val / this.nzStep) * this.nzStep;\n            points.push(closestOne);\n        }\n        const gaps = points.map(point => Math.abs(val - point));\n        const closest = points[gaps.indexOf(Math.min(...gaps))];\n        // return parseFloat(closest.toFixed(getPrecision(this.nzStep)));\n        return this.nzStep === 0 ? closest : parseFloat(closest.toFixed(getPrecision(this.nzStep)));\n    }\n    valueToOffset(value) {\n        return getPercent(this.nzMin, this.nzMax, value);\n    }\n    getSliderStartPosition() {\n        if (this.cacheSliderStart !== null) {\n            return this.cacheSliderStart;\n        }\n        const offset = getElementOffset(this.slider.nativeElement);\n        return this.nzVertical ? offset.top : offset.left;\n    }\n    getSliderLength() {\n        if (this.cacheSliderLength !== null) {\n            return this.cacheSliderLength;\n        }\n        const sliderDOM = this.slider.nativeElement;\n        return this.nzVertical ? sliderDOM.clientHeight : sliderDOM.clientWidth;\n    }\n    /**\n     * Cache DOM layout/reflow operations for performance (may not necessary?)\n     */\n    cacheSliderProperty(remove = false) {\n        this.cacheSliderStart = remove ? null : this.getSliderStartPosition();\n        this.cacheSliderLength = remove ? null : this.getSliderLength();\n    }\n    formatValue(value) {\n        if (!value) {\n            return this.nzRange ? [this.nzMin, this.nzMax] : this.nzMin;\n        }\n        else if (assertValueValid(value, this.nzRange)) {\n            return isValueRange(value)\n                ? value.map(val => ensureNumberInRange(val, this.nzMin, this.nzMax))\n                : ensureNumberInRange(value, this.nzMin, this.nzMax);\n        }\n        else {\n            return this.nzDefaultValue ? this.nzDefaultValue : this.nzRange ? [this.nzMin, this.nzMax] : this.nzMin;\n        }\n    }\n    /**\n     * Show one handle's tooltip and hide others'.\n     */\n    showHandleTooltip(handleIndex = 0) {\n        this.handles.forEach((handle, index) => {\n            handle.active = index === handleIndex;\n        });\n    }\n    hideAllHandleTooltip() {\n        this.handles.forEach(handle => (handle.active = false));\n    }\n    generateMarkItems(marks) {\n        const marksArray = [];\n        for (const key in marks) {\n            const mark = marks[key];\n            const val = typeof key === 'number' ? key : parseFloat(key);\n            if (val >= this.nzMin && val <= this.nzMax) {\n                marksArray.push({ value: val, offset: this.valueToOffset(val), config: mark });\n            }\n        }\n        return marksArray.length ? marksArray : null;\n    }\n}\n/** @nocollapse */\nNzSliderComponent.ɵfac = function NzSliderComponent_Factory(t) { return new (t || NzSliderComponent)(ɵngcc0.ɵɵdirectiveInject(NzSliderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform)); };\n/** @nocollapse */\nNzSliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NzSliderComponent, selectors: [[\"nz-slider\"]], viewQuery: function NzSliderComponent_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵstaticViewQuery(_c1, true);\n        ɵngcc0.ɵɵviewQuery(NzSliderHandleComponent, true);\n    } if (rf & 2) {\n        var _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.slider = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.handlerComponents = _t);\n    } }, hostBindings: function NzSliderComponent_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function NzSliderComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });\n    } }, inputs: { nzDisabled: \"nzDisabled\", nzDots: \"nzDots\", nzIncluded: \"nzIncluded\", nzRange: \"nzRange\", nzVertical: \"nzVertical\", nzReverse: \"nzReverse\", nzMarks: \"nzMarks\", nzMax: \"nzMax\", nzMin: \"nzMin\", nzStep: \"nzStep\", nzTooltipVisible: \"nzTooltipVisible\", nzTooltipPlacement: \"nzTooltipPlacement\", nzDefaultValue: \"nzDefaultValue\", nzTipFormatter: \"nzTipFormatter\" }, outputs: { nzOnAfterChange: \"nzOnAfterChange\" }, exportAs: [\"nzSlider\"], features: [ɵngcc0.ɵɵProvidersFeature([\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef((() => NzSliderComponent)),\n                multi: true\n            },\n            NzSliderService\n        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 14, consts: [[1, \"ant-slider\"], [\"slider\", \"\"], [1, \"ant-slider-rail\"], [3, \"vertical\", \"included\", \"offset\", \"length\", \"reverse\"], [3, \"vertical\", \"lowerBound\", \"upperBound\", \"marksArray\", \"included\", 4, \"ngIf\"], [3, \"vertical\", \"reverse\", \"offset\", \"value\", \"active\", \"tooltipFormatter\", \"tooltipVisible\", \"tooltipPlacement\", 4, \"ngFor\", \"ngForOf\"], [3, \"vertical\", \"min\", \"max\", \"lowerBound\", \"upperBound\", \"marksArray\", \"included\", 4, \"ngIf\"], [3, \"vertical\", \"lowerBound\", \"upperBound\", \"marksArray\", \"included\"], [3, \"vertical\", \"reverse\", \"offset\", \"value\", \"active\", \"tooltipFormatter\", \"tooltipVisible\", \"tooltipPlacement\"], [3, \"vertical\", \"min\", \"max\", \"lowerBound\", \"upperBound\", \"marksArray\", \"included\"]], template: function NzSliderComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵelement(2, \"div\", 2);\n        ɵngcc0.ɵɵelement(3, \"nz-slider-track\", 3);\n        ɵngcc0.ɵɵtemplate(4, NzSliderComponent_nz_slider_step_4_Template, 1, 5, \"nz-slider-step\", 4);\n        ɵngcc0.ɵɵtemplate(5, NzSliderComponent_nz_slider_handle_5_Template, 1, 8, \"nz-slider-handle\", 5);\n        ɵngcc0.ɵɵtemplate(6, NzSliderComponent_nz_slider_marks_6_Template, 1, 7, \"nz-slider-marks\", 6);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"ant-slider-disabled\", ctx.nzDisabled)(\"ant-slider-vertical\", ctx.nzVertical)(\"ant-slider-with-marks\", ctx.marksArray);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"vertical\", ctx.nzVertical)(\"included\", ctx.nzIncluded)(\"offset\", ctx.track.offset)(\"length\", ctx.track.length)(\"reverse\", ctx.nzReverse);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.marksArray);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.handles);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.marksArray);\n    } }, directives: function () { return [NzSliderTrackComponent, ɵngcc2.NgIf, ɵngcc2.NgForOf, NzSliderStepComponent, NzSliderHandleComponent, NzSliderMarksComponent]; }, encapsulation: 2, changeDetection: 0 });\nNzSliderComponent.ctorParameters = () => [\n    { type: NzSliderService },\n    { type: ChangeDetectorRef },\n    { type: Platform }\n];\nNzSliderComponent.propDecorators = {\n    slider: [{ type: ViewChild, args: ['slider', { static: true },] }],\n    handlerComponents: [{ type: ViewChildren, args: [NzSliderHandleComponent,] }],\n    nzDisabled: [{ type: Input }],\n    nzDots: [{ type: Input }],\n    nzIncluded: [{ type: Input }],\n    nzRange: [{ type: Input }],\n    nzVertical: [{ type: Input }],\n    nzReverse: [{ type: Input }],\n    nzDefaultValue: [{ type: Input }],\n    nzMarks: [{ type: Input }],\n    nzMax: [{ type: Input }],\n    nzMin: [{ type: Input }],\n    nzStep: [{ type: Input }],\n    nzTooltipVisible: [{ type: Input }],\n    nzTooltipPlacement: [{ type: Input }],\n    nzTipFormatter: [{ type: Input }],\n    nzOnAfterChange: [{ type: Output }]\n};\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Object)\n], NzSliderComponent.prototype, \"nzDisabled\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Boolean)\n], NzSliderComponent.prototype, \"nzDots\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Boolean)\n], NzSliderComponent.prototype, \"nzIncluded\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Boolean)\n], NzSliderComponent.prototype, \"nzRange\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Boolean)\n], NzSliderComponent.prototype, \"nzVertical\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Boolean)\n], NzSliderComponent.prototype, \"nzReverse\", void 0);\n__decorate([\n    InputNumber(),\n    __metadata(\"design:type\", Object)\n], NzSliderComponent.prototype, \"nzMax\", void 0);\n__decorate([\n    InputNumber(),\n    __metadata(\"design:type\", Object)\n], NzSliderComponent.prototype, \"nzMin\", void 0);\n__decorate([\n    InputNumber(),\n    __metadata(\"design:type\", Object)\n], NzSliderComponent.prototype, \"nzStep\", void 0);\nfunction getValueTypeNotMatchError() {\n    return new Error(`The \"nzRange\" can't match the \"ngModel\"'s type, please check these properties: \"nzRange\", \"ngModel\", \"nzDefaultValue\".`);\n}\nfunction isValueRange(value) {\n    if (value instanceof Array) {\n        return value.length === 2;\n    }\n    else {\n        return false;\n    }\n}\nfunction generateHandlers(amount) {\n    return Array(amount)\n        .fill(0)\n        .map(() => ({ offset: null, value: null, active: false }));\n}\n/**\n * Check if value is valid and throw error if value-type/range not match.\n */\nfunction assertValueValid(value, isRange) {\n    if ((!isValueRange(value) && isNaN(value)) || (isValueRange(value) && value.some(v => isNaN(v)))) {\n        return false;\n    }\n    return assertValueTypeMatch(value, isRange);\n}\n/**\n * Assert that if `this.nzRange` is `true`, value is also a range, vice versa.\n */\nfunction assertValueTypeMatch(value, isRange = false) {\n    if (isValueRange(value) !== isRange) {\n        throw getValueTypeNotMatchError();\n    }\n    return true;\n}\nfunction valuesEqual(valA, valB) {\n    if (typeof valA !== typeof valB) {\n        return false;\n    }\n    return isValueRange(valA) && isValueRange(valB) ? arraysEqual(valA, valB) : valA === valB;\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSliderMarksComponent {\n    constructor() {\n        this.lowerBound = null;\n        this.upperBound = null;\n        this.marksArray = [];\n        this.vertical = false;\n        this.included = false;\n        this.marks = [];\n    }\n    ngOnChanges(changes) {\n        const { marksArray, lowerBound, upperBound } = changes;\n        if (marksArray) {\n            this.buildMarks();\n        }\n        if (marksArray || lowerBound || upperBound) {\n            this.togglePointActive();\n        }\n    }\n    trackById(_index, mark) {\n        return mark.value;\n    }\n    buildMarks() {\n        const range = this.max - this.min;\n        this.marks = this.marksArray.map(mark => {\n            const { value, offset, config } = mark;\n            const style = this.getMarkStyles(value, range, config);\n            const label = isConfigObject(config) ? config.label : config;\n            return {\n                label,\n                offset,\n                style,\n                value,\n                config,\n                active: false\n            };\n        });\n    }\n    getMarkStyles(value, range, config) {\n        let style;\n        if (this.vertical) {\n            style = {\n                marginBottom: '-50%',\n                bottom: `${((value - this.min) / range) * 100}%`\n            };\n        }\n        else {\n            style = {\n                transform: `translate3d(-50%, 0, 0)`,\n                left: `${((value - this.min) / range) * 100}%`\n            };\n        }\n        if (isConfigObject(config) && config.style) {\n            style = Object.assign(Object.assign({}, style), config.style);\n        }\n        return style;\n    }\n    togglePointActive() {\n        if (this.marks && this.lowerBound !== null && this.upperBound !== null) {\n            this.marks.forEach(mark => {\n                const value = mark.value;\n                const isActive = (!this.included && value === this.upperBound) || (this.included && value <= this.upperBound && value >= this.lowerBound);\n                mark.active = isActive;\n            });\n        }\n    }\n}\n/** @nocollapse */\nNzSliderMarksComponent.ɵfac = function NzSliderMarksComponent_Factory(t) { return new (t || NzSliderMarksComponent)(); };\n/** @nocollapse */\nNzSliderMarksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NzSliderMarksComponent, selectors: [[\"nz-slider-marks\"]], inputs: { lowerBound: \"lowerBound\", upperBound: \"upperBound\", marksArray: \"marksArray\", vertical: \"vertical\", included: \"included\", min: \"min\", max: \"max\" }, exportAs: [\"nzSliderMarks\"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 2, consts: [[1, \"ant-slider-mark\"], [\"class\", \"ant-slider-mark-text\", 3, \"ant-slider-mark-active\", \"ngStyle\", \"innerHTML\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"ant-slider-mark-text\", 3, \"ngStyle\", \"innerHTML\"]], template: function NzSliderMarksComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, NzSliderMarksComponent_span_1_Template, 1, 4, \"span\", 1);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.marks)(\"ngForTrackBy\", ctx.trackById);\n    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgStyle], encapsulation: 2, changeDetection: 0 });\nNzSliderMarksComponent.propDecorators = {\n    lowerBound: [{ type: Input }],\n    upperBound: [{ type: Input }],\n    marksArray: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    vertical: [{ type: Input }],\n    included: [{ type: Input }]\n};\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Object)\n], NzSliderMarksComponent.prototype, \"vertical\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Object)\n], NzSliderMarksComponent.prototype, \"included\", void 0);\nfunction isConfigObject(config) {\n    return typeof config !== 'string';\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSliderStepComponent {\n    constructor() {\n        this.lowerBound = null;\n        this.upperBound = null;\n        this.marksArray = [];\n        this.vertical = false;\n        this.included = false;\n        this.steps = [];\n    }\n    ngOnChanges(changes) {\n        if (changes.marksArray) {\n            this.buildSteps();\n        }\n        if (changes.marksArray || changes.lowerBound || changes.upperBound) {\n            this.togglePointActive();\n        }\n    }\n    trackById(_index, step) {\n        return step.value;\n    }\n    buildSteps() {\n        const orient = this.vertical ? 'bottom' : 'left';\n        this.steps = this.marksArray.map(mark => {\n            const { value, offset, config } = mark;\n            return {\n                value,\n                offset,\n                config,\n                active: false,\n                style: {\n                    [orient]: `${offset}%`\n                }\n            };\n        });\n    }\n    togglePointActive() {\n        if (this.steps && this.lowerBound !== null && this.upperBound !== null) {\n            this.steps.forEach(step => {\n                const value = step.value;\n                const isActive = (!this.included && value === this.upperBound) || (this.included && value <= this.upperBound && value >= this.lowerBound);\n                step.active = isActive;\n            });\n        }\n    }\n}\n/** @nocollapse */\nNzSliderStepComponent.ɵfac = function NzSliderStepComponent_Factory(t) { return new (t || NzSliderStepComponent)(); };\n/** @nocollapse */\nNzSliderStepComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NzSliderStepComponent, selectors: [[\"nz-slider-step\"]], inputs: { lowerBound: \"lowerBound\", upperBound: \"upperBound\", marksArray: \"marksArray\", vertical: \"vertical\", included: \"included\" }, exportAs: [\"nzSliderStep\"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 2, consts: [[1, \"ant-slider-step\"], [\"class\", \"ant-slider-dot\", 3, \"ant-slider-dot-active\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"ant-slider-dot\", 3, \"ngStyle\"]], template: function NzSliderStepComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, NzSliderStepComponent_span_1_Template, 1, 3, \"span\", 1);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.steps)(\"ngForTrackBy\", ctx.trackById);\n    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgStyle], encapsulation: 2, changeDetection: 0 });\nNzSliderStepComponent.propDecorators = {\n    lowerBound: [{ type: Input }],\n    upperBound: [{ type: Input }],\n    marksArray: [{ type: Input }],\n    vertical: [{ type: Input }],\n    included: [{ type: Input }]\n};\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Object)\n], NzSliderStepComponent.prototype, \"vertical\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Object)\n], NzSliderStepComponent.prototype, \"included\", void 0);\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSliderTrackComponent {\n    constructor() {\n        this.offset = 0;\n        this.reverse = false;\n        this.length = 0;\n        this.vertical = false;\n        this.included = false;\n        this.style = {};\n    }\n    ngOnChanges() {\n        const vertical = this.vertical;\n        const reverse = this.reverse;\n        const visibility = this.included ? 'visible' : 'hidden';\n        const offset = this.offset;\n        const length = this.length;\n        const positonStyle = vertical\n            ? {\n                [reverse ? 'top' : 'bottom']: `${offset}%`,\n                [reverse ? 'bottom' : 'top']: 'auto',\n                height: `${length}%`,\n                visibility\n            }\n            : {\n                [reverse ? 'right' : 'left']: `${offset}%`,\n                [reverse ? 'left' : 'right']: 'auto',\n                width: `${length}%`,\n                visibility\n            };\n        this.style = positonStyle;\n    }\n}\n/** @nocollapse */\nNzSliderTrackComponent.ɵfac = function NzSliderTrackComponent_Factory(t) { return new (t || NzSliderTrackComponent)(); };\n/** @nocollapse */\nNzSliderTrackComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NzSliderTrackComponent, selectors: [[\"nz-slider-track\"]], inputs: { offset: \"offset\", reverse: \"reverse\", length: \"length\", vertical: \"vertical\", included: \"included\" }, exportAs: [\"nzSliderTrack\"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [[1, \"ant-slider-track\", 3, \"ngStyle\"]], template: function NzSliderTrackComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n    } if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.style);\n    } }, directives: [ɵngcc2.NgStyle], encapsulation: 2, changeDetection: 0 });\nNzSliderTrackComponent.propDecorators = {\n    offset: [{ type: Input }],\n    reverse: [{ type: Input }],\n    length: [{ type: Input }],\n    vertical: [{ type: Input }],\n    included: [{ type: Input }]\n};\n__decorate([\n    InputNumber(),\n    __metadata(\"design:type\", Number)\n], NzSliderTrackComponent.prototype, \"offset\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Boolean)\n], NzSliderTrackComponent.prototype, \"reverse\", void 0);\n__decorate([\n    InputNumber(),\n    __metadata(\"design:type\", Number)\n], NzSliderTrackComponent.prototype, \"length\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Object)\n], NzSliderTrackComponent.prototype, \"vertical\", void 0);\n__decorate([\n    InputBoolean(),\n    __metadata(\"design:type\", Object)\n], NzSliderTrackComponent.prototype, \"included\", void 0);\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzSliderService, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzSliderHandleComponent, [{\n        type: Component,\n        args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                selector: 'nz-slider-handle',\n                exportAs: 'nzSliderHandle',\n                preserveWhitespaces: false,\n                template: `\n    <div\n      #handle\n      class=\"ant-slider-handle\"\n      tabindex=\"0\"\n      nz-tooltip\n      [ngStyle]=\"style\"\n      [nzTooltipTitle]=\"tooltipFormatter === null || tooltipVisible === 'never' ? null : tooltipTitle\"\n      [nzTooltipTrigger]=\"null\"\n      [nzTooltipPlacement]=\"tooltipPlacement\"\n    ></div>\n  `,\n                host: {\n                    '(mouseenter)': 'enterHandle()',\n                    '(mouseleave)': 'leaveHandle()'\n                }\n            }]\n    }], function () { return [{ type: NzSliderService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { tooltipVisible: [{\n            type: Input\n        }], active: [{\n            type: Input\n        }], handleEl: [{\n            type: ViewChild,\n            args: ['handle', { static: false }]\n        }], tooltip: [{\n            type: ViewChild,\n            args: [NzTooltipDirective, { static: false }]\n        }], vertical: [{\n            type: Input\n        }], reverse: [{\n            type: Input\n        }], offset: [{\n            type: Input\n        }], value: [{\n            type: Input\n        }], tooltipPlacement: [{\n            type: Input\n        }], tooltipFormatter: [{\n            type: Input\n        }] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzSliderComponent, [{\n        type: Component,\n        args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                selector: 'nz-slider',\n                exportAs: 'nzSlider',\n                preserveWhitespaces: false,\n                providers: [\n                    {\n                        provide: NG_VALUE_ACCESSOR,\n                        useExisting: forwardRef((() => NzSliderComponent)),\n                        multi: true\n                    },\n                    NzSliderService\n                ],\n                host: {\n                    '(keydown)': 'onKeyDown($event)'\n                },\n                template: `\n    <div\n      #slider\n      class=\"ant-slider\"\n      [class.ant-slider-disabled]=\"nzDisabled\"\n      [class.ant-slider-vertical]=\"nzVertical\"\n      [class.ant-slider-with-marks]=\"marksArray\"\n    >\n      <div class=\"ant-slider-rail\"></div>\n      <nz-slider-track\n        [vertical]=\"nzVertical\"\n        [included]=\"nzIncluded\"\n        [offset]=\"track.offset!\"\n        [length]=\"track.length!\"\n        [reverse]=\"nzReverse\"\n      ></nz-slider-track>\n      <nz-slider-step\n        *ngIf=\"marksArray\"\n        [vertical]=\"nzVertical\"\n        [lowerBound]=\"$any(bounds.lower)\"\n        [upperBound]=\"$any(bounds.upper)\"\n        [marksArray]=\"marksArray\"\n        [included]=\"nzIncluded\"\n      ></nz-slider-step>\n      <nz-slider-handle\n        *ngFor=\"let handle of handles\"\n        [vertical]=\"nzVertical\"\n        [reverse]=\"nzReverse\"\n        [offset]=\"handle.offset!\"\n        [value]=\"handle.value!\"\n        [active]=\"handle.active\"\n        [tooltipFormatter]=\"nzTipFormatter\"\n        [tooltipVisible]=\"nzTooltipVisible\"\n        [tooltipPlacement]=\"nzTooltipPlacement\"\n      ></nz-slider-handle>\n      <nz-slider-marks\n        *ngIf=\"marksArray\"\n        [vertical]=\"nzVertical\"\n        [min]=\"nzMin\"\n        [max]=\"nzMax\"\n        [lowerBound]=\"$any(bounds.lower)\"\n        [upperBound]=\"$any(bounds.upper)\"\n        [marksArray]=\"marksArray\"\n        [included]=\"nzIncluded\"\n      ></nz-slider-marks>\n    </div>\n  `\n            }]\n    }], function () { return [{ type: NzSliderService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc3.Platform }]; }, { nzDisabled: [{\n            type: Input\n        }], nzDots: [{\n            type: Input\n        }], nzIncluded: [{\n            type: Input\n        }], nzRange: [{\n            type: Input\n        }], nzVertical: [{\n            type: Input\n        }], nzReverse: [{\n            type: Input\n        }], nzMarks: [{\n            type: Input\n        }], nzMax: [{\n            type: Input\n        }], nzMin: [{\n            type: Input\n        }], nzStep: [{\n            type: Input\n        }], nzTooltipVisible: [{\n            type: Input\n        }], nzTooltipPlacement: [{\n            type: Input\n        }], nzOnAfterChange: [{\n            type: Output\n        }], slider: [{\n            type: ViewChild,\n            args: ['slider', { static: true }]\n        }], handlerComponents: [{\n            type: ViewChildren,\n            args: [NzSliderHandleComponent]\n        }], nzDefaultValue: [{\n            type: Input\n        }], nzTipFormatter: [{\n            type: Input\n        }] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzSliderMarksComponent, [{\n        type: Component,\n        args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                preserveWhitespaces: false,\n                selector: 'nz-slider-marks',\n                exportAs: 'nzSliderMarks',\n                template: `\n    <div class=\"ant-slider-mark\">\n      <span\n        class=\"ant-slider-mark-text\"\n        *ngFor=\"let attr of marks; trackBy: trackById\"\n        [class.ant-slider-mark-active]=\"attr.active\"\n        [ngStyle]=\"attr.style!\"\n        [innerHTML]=\"attr.label\"\n      >\n      </span>\n    </div>\n  `\n            }]\n    }], function () { return []; }, { lowerBound: [{\n            type: Input\n        }], upperBound: [{\n            type: Input\n        }], marksArray: [{\n            type: Input\n        }], vertical: [{\n            type: Input\n        }], included: [{\n            type: Input\n        }], min: [{\n            type: Input\n        }], max: [{\n            type: Input\n        }] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzSliderStepComponent, [{\n        type: Component,\n        args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                selector: 'nz-slider-step',\n                exportAs: 'nzSliderStep',\n                preserveWhitespaces: false,\n                template: `\n    <div class=\"ant-slider-step\">\n      <span\n        class=\"ant-slider-dot\"\n        *ngFor=\"let mark of steps; trackBy: trackById\"\n        [class.ant-slider-dot-active]=\"mark.active\"\n        [ngStyle]=\"mark.style!\"\n      >\n      </span>\n    </div>\n  `\n            }]\n    }], function () { return []; }, { lowerBound: [{\n            type: Input\n        }], upperBound: [{\n            type: Input\n        }], marksArray: [{\n            type: Input\n        }], vertical: [{\n            type: Input\n        }], included: [{\n            type: Input\n        }] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzSliderTrackComponent, [{\n        type: Component,\n        args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                selector: 'nz-slider-track',\n                exportAs: 'nzSliderTrack',\n                preserveWhitespaces: false,\n                template: ` <div class=\"ant-slider-track\" [ngStyle]=\"style\"></div> `\n            }]\n    }], function () { return []; }, { offset: [{\n            type: Input\n        }], reverse: [{\n            type: Input\n        }], length: [{\n            type: Input\n        }], vertical: [{\n            type: Input\n        }], included: [{\n            type: Input\n        }] }); })();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSliderModule {\n}\n/** @nocollapse */\nNzSliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NzSliderModule });\n/** @nocollapse */\nNzSliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NzSliderModule_Factory(t) { return new (t || NzSliderModule)(); }, imports: [[CommonModule, PlatformModule, NzToolTipModule]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzSliderModule, { declarations: function () { return [NzSliderComponent, NzSliderTrackComponent, NzSliderHandleComponent, NzSliderStepComponent, NzSliderMarksComponent]; }, imports: function () { return [CommonModule, PlatformModule, NzToolTipModule]; }, exports: function () { return [NzSliderComponent, NzSliderTrackComponent, NzSliderHandleComponent, NzSliderStepComponent, NzSliderMarksComponent]; } }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzSliderModule, [{\n        type: NgModule,\n        args: [{\n                exports: [NzSliderComponent, NzSliderTrackComponent, NzSliderHandleComponent, NzSliderStepComponent, NzSliderMarksComponent],\n                declarations: [NzSliderComponent, NzSliderTrackComponent, NzSliderHandleComponent, NzSliderStepComponent, NzSliderMarksComponent],\n                imports: [CommonModule, PlatformModule, NzToolTipModule]\n            }]\n    }], null, null); })();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzMarks {\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzMarks, NzSliderComponent, NzSliderModule, NzSliderHandleComponent as ɵNzSliderHandleComponent, NzSliderMarksComponent as ɵNzSliderMarksComponent, NzSliderService as ɵNzSliderService, NzSliderStepComponent as ɵNzSliderStepComponent, NzSliderTrackComponent as ɵNzSliderTrackComponent };\n\n//# sourceMappingURL=ng-zorro-antd-slider.js.map"],"sourceRoot":"webpack:///"}