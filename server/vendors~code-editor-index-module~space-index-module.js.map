{"version":3,"sources":["./node_modules/@angular/core/__ivy_ngcc__/fesm2015/testing.js"],"names":[],"mappings":";;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEywB;AACvuB;AACiB;;AAEnD;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AAC2B;AACxC,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,6BAA6B,EAAE;AAC/B;AACA,2BAA2B,EAAE;AAC7B,4BAA4B;AAC5B;AACA,8BAA8B,SAAS,EAAE;AACzC;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,cAAc;AACd,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,sCAAsC,EAAE,kBAAkB,EAAE;AAC5D;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA,gBAAgB,EAAE,iBAAiB,EAAE;AACrC,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE,KAAK,kEAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,iDAAiD;AACjD,oCAAoC;AACpC;AACA,+BAA+B,wBAAwB,EAAE,GAAG;AAC5D;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,oDAAoD,EAAE;AACtD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,8CAA8C;AAC9C,mCAAmC,EAAE;AACrC,oCAAoC;AACpC;AACA,oCAAoC,aAAa,EAAE,GAAG;AACtD,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,mBAAmB,4BAA4B,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,uCAAuC,EAAE,wCAAwC;AACjG;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA,oBAAoB,qBAAqB,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,4DAA4D,8DAAgB;AAC5E;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAgFV;AACD;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,EAAE;AACb,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,eAAe,KAAK;AACpB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAoD;AACvF;AACA;AACA;AACA,mCAAmC,4CAA4C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,EAAE;AACb,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA,iBAAiB,sBAAsB;AACvC;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA,6BAA6B,qBAAqB;AAClD;AACA,gBAAgB;AAChB;AACA,mBAAmB,sBAAsB;AACzC;AACA,WAAW,EAgBV;;AAED;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,sCAAsC;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC,4DAAc;AACrD;AACA;AACA,UAAU;AACV;AACA,qCAAqC,4DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,WAAW,EA0IV;;AAED;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,YAAY;AACZ;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,4BAA4B;AAC5B;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,mBAAmB,EAAE;AACrB;AACA,oBAAoB;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA,6DAA6D,gEAAU,gBAAgB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA;AACA,WAAW,EAMV;AACD;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA,wBAAwB,0DAA0D,EAAE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc,SAAS,GAAG,oCAAoC;AAC9D;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA,gBAAgB,gEAAU,MAAM,EAAE,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,EAAE;AACb,uBAAuB,qEAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,WAAW,EAiBV;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,+BAA+B,kCAAkC,EAAE;AACnE;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB,sDAAsD,uDAAS,0BAA0B,uDAAS;AAClG,sCAAsC,kDAAI,0BAA0B,sDAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA,+BAA+B,EAAE;AACjC,gCAAgC;AAChC;AACA;AACA,qFAAqF,EAAE;AACvF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAgBV;AACD;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,QAAQ,uDAAS,CAAC;AAClC;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,QAAQ,uDAAS,CAAC;AAClC;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,QAAQ,kDAAI,CAAC;AAC7B;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,QAAQ,sDAAQ,CAAC;AACjC;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,WAAW,EAOV;AACD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,EAAE;AAC5C;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,2BAA2B;AAC3B;AACA,mBAAmB,EAAE;AACrB,0DAA0D,uEAAiB;AAC3E,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,iCAAiC,EAAE,aAAa,0DAAY;AAC5D,mBAAmB,EAAE;AACrB;AACA,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB,yCAAyC,EAAE,iBAAiB,EAAE;AAC9D;AACA,SAAS;AACT,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,8CAA8C,sCAAsC,IAAI;AACxF,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,uDAAS;AACxB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA,2DAA2D,gEAAc;AACzE;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,iCAAiC,iEAAmB;AACpD;AACA;AACA,qBAAqB,EAAE,qCAAqC,mEAAqB;AACjF;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,yDAAyD,uDAAS,EAAE,gEAAkB;AACtF,QAAQ,kEAAY;AACpB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,uDAAS;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB,8CAA8C,EAAE;AAChD,+CAA+C,sEAAwB,2BAA2B,EAAE;AACpG;AACA,SAAS,eAAe,EAAE;AAC1B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,iCAAiC,0DAAY;AAC7C,YAAY,uEAAiB;AAC7B,SAAS;AACT;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,iCAAiC,yDAAW;AAC5C,YAAY,uEAAiB;AAC7B,SAAS;AACT;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,iCAAiC,0DAAY;AAC7C,YAAY,kEAAY;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B,qFAAqF,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,EAAE,mBAAmB,yDAAW;AAC3F,iCAAiC,EAAE,mBAAmB,yDAAW;AACjE;AACA,8CAA8C,0EAAoB;AAClE;AACA,+BAA+B,EAAE;AACjC,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,sDAAsD,0DAAY;AAClE,sDAAsD,0DAAY;AAClE,YAAY,iFAA2B,cAAc,EAAE;AACvD,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB,uCAAuC,0DAAY;AACnD,uBAAuB,EAAE;AACzB,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA,SAAS;AACT,wDAAwD,0DAAY;AACpE,wDAAwD,yDAAW;AACnE;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,yCAAyC,EAAE,mBAAmB,yDAAW;AACzE;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,mEAAmE,EAAE;AACrE;AACA;AACA,qCAAqC,yDAAW;AAChD,uDAAuD,yDAAW;AAClE;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,2CAA2C,EAAE,mBAAmB,yDAAW;AAC3E,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,uCAAuC,EAAE,aAAa,0DAAY;AAClE;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,6BAA6B,yDAAW;AACxC,6BAA6B,yDAAW;AACxC,QAAQ,0EAAoB,aAAa,EAAE;AAC3C;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,8EAA8E,0DAAY;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,qCAAqC,yDAAW;AAChD;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,yCAAyC,0DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,iCAAiC,EAAE;AACnC,mBAAmB,EAAE;AACrB;AACA,iCAAiC,wCAAwC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,kEAAY,CAAC,gEAAkB;AACvC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,QAAQ,0EAAoB,aAAa,EAAE;AAC3C;AACA,SAAS;AACT,mBAAmB,EAAE;AACrB,2BAA2B,oDAAM,EAAE,6BAA6B;AAChE,mBAAmB,EAAE;AACrB;AACA,aAAa,UAAU,oDAAM,oBAAoB;AACjD,aAAa,UAAU,sDAAQ;AAC/B,4BAA4B;AAC5B;AACA,iDAAiD;AACjD;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,QAAQ,0EAAoB;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,2DAA2D,8DAAgB;AAC3E;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAoB,aAAa,EAAE,wBAAwB,YAAY;AAC/E,mBAAmB,EAAE;AACrB,0CAA0C,8DAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,2DAA2D,aAAa;AACxE;AACA;AACA,gEAAgE,cAAc,eAAe;AAC7F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,iCAAiC,EAAE;AACnC;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,EAwIV;AACD;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,oEAAoE,EAAE;AACtE;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,wBAAwB,KAAK,uBAAuB,aAAa;AACjE;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,8DAAgB;AACnC;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,uDAAS;AACxB;AACA,uBAAuB,8DAAgB;AACvC,SAAS;AACT;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,mFAAmF,EAAE;AACrF,mBAAmB,0EAA4B;AAC/C;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,uDAAS;AACxB,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB,uFAAuF,EAAE;AACzF,uBAAuB,0EAA4B;AACnD,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA,kBAAkB;AAClB;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,yBAAyB;AACzB;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,WAAW,EAMV;;AAED;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,mCAAmC,6CAA6C;AAChF;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gCAAgC,iDAAiD;AACjF;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,2DAA2D,OAAO,oCAAoC,EAAE,aAAa,EAAE;AACvH,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA,sCAAsC,sDAAQ,6BAA6B,yDAAW;AACtF;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC,oCAAoC,EAAE;AACtC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,QAAQ,8EAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,yBAAyB,0CAA0C;AACnE;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,wBAAwB,EAAE;AAC1B,+BAA+B,EAAE;AACjC;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,kDAAkD,EAAE;AACpD;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA,+BAA+B,sDAAQ,6BAA6B,yDAAW;AAC/E;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,sDAAsD,qBAAqB;AAC3E;AACA,mBAAmB,EAAE;AACrB,0CAA0C,EAAE;AAC5C;AACA,8CAA8C,gEAAU,OAAO;AAC/D;AACA;AACA,mBAAmB,EAAE;AACrB,iDAAiD,EAAE;AACnD;AACA,mBAAmB,EAAE;AACrB,mDAAmD,EAAE;AACrD,mBAAmB,EAAE;AACrB,qDAAqD,oDAAM;AAC3D,mBAAmB,EAAE;AACrB,qCAAqC,sEAAwB;AAC7D,mBAAmB,EAAE;AACrB;AACA,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB,yDAAyD,sDAAQ,eAAe,SAAS;AACzF;AACA,SAAS;AACT,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD,mEAAmE,WAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,YAAY,8FAAwC;AACpD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW,EAyBV;AACD,WAAW,EAAE;AACb;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAQ;AACtC;AACA,gBAAgB;AAChB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,kCAAkC,uBAAuB;AACzD;AACA,4DAA4D,2DAA2D;AACvH,wBAAwB,gEAAyB,EAAE,wDAAwD;AAC3G,qCAAqC,mEAA4B;AACjE,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB,KAAK,eAAe,EAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAOV;;AAED;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,EAAE;AACvC,sCAAsC,EAAE;AACxC,0CAA0C,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,mCAAmC,gDAAgD;AACnF;AACA,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gCAAgC,yCAAyC;AACzE;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,8DAA8D,OAAO,oCAAoC,EAAE,aAAa,EAAE;AAC1H,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,oEAAoE,EAAE;AACtE,2BAA2B,EAAE,iBAAiB,EAAE;AAChD;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA,sCAAsC,sDAAQ,6BAA6B,yDAAW;AACtF;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,oCAAoC,EAAE;AACtC,oCAAoC,EAAE;AACtC;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ,qEAAe;AACvB;AACA;AACA,qCAAqC,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,EAAE;AACxC,0CAA0C,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA,2EAA2E,gEAAU,gBAAgB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C,uBAAuB,EAAE;AACzB;AACA,YAAY,4EAAsB;AAClC;AACA,mBAAmB,EAAE;AACrB,2BAA2B,oDAAM,EAAE,wEAAwE;AAC3G,mBAAmB,EAAE;AACrB,4BAA4B,UAAU,oDAAM,oBAAoB;AAChE,mBAAmB,EAAE;AACrB,+BAA+B,sDAAQ;AACvC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,EAAE,kCAAkC,mEAAqB;AAC9E;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,mDAAmD,mCAAmC;AACtF,mBAAmB,EAAE;AACrB;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO,sDAAQ;AAChC;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA,wBAAwB,UAAU,6DAAe,0CAA0C;AAC3F,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,aAAa,OAAO,sDAAQ,UAAU,uDAAuD,IAAI;AACjG;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD,mEAAmE,WAAW;AAC9E;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,wBAAwB,EAAE;AAC1B,+BAA+B,EAAE;AACjC;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,kDAAkD,EAAE;AACpD;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA,+BAA+B,sDAAQ,6BAA6B,yDAAW;AAC/E;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,gDAAgD,uEAAiB;AACjE;AACA,kDAAkD,6EAA6E;AAC/H;AACA;AACA,kDAAkD,8CAA8C;AAChG;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B,4BAA4B;AAC5B;AACA;AACA,yCAAyC,sDAAQ;AACjD;AACA;AACA,8CAA8C,sDAAQ;AACtD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,uEAAiB,EAAE,4DAA4D;AACvF;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,uDAAS,UAAU,yCAAyC,IAAI;AACpF;AACA,sCAAsC,2CAA2C;AACjF;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,2DAA2D,gEAAU,YAAY;AACjF;AACA;AACA,mBAAmB,EAAE;AACrB,iDAAiD,EAAE;AACnD;AACA,mBAAmB,EAAE;AACrB,mDAAmD,EAAE;AACrD,mBAAmB,EAAE;AACrB,qDAAqD,oDAAM;AAC3D,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,gCAAgC,uBAAuB;AACvD;AACA,mBAAmB,EAAE;AACrB;AACA,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB,yDAAyD,sDAAQ,eAAe,SAAS;AACzF;AACA,SAAS;AACT,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,WAAW,EAoGV;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gBAAgB,yDAAW,eAAe,EAAE,iBAAiB,EAAE,sCAAsC,EAAE,iBAAiB,EAAE;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,mBAAmB,yDAAW;AAC9B,WAAW,EAAE;AACb;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,iFAAiF,MAAM,EAAE;AACzF;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB;AACA,qBAAqB,0CAA0C,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW,EAMV;AACD;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,EAAE;AACb,8BAA8B,EAAE;AAChC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;;AAEA;AACA;AACA;;AAEkmB;;AAElmB,mC","file":"vendors~code-editor-index-module~space-index-module.js","sourcesContent":["/**\n * @license Angular v9.1.1\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { getDebugNode, RendererFactory2, InjectionToken, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, Injector, InjectFlags, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible, Injectable, ɵclearOverrides, ɵoverrideComponentView, ɵINJECTOR_SCOPE, Optional, SkipSelf, ɵoverrideProvider, ɵivyEnabled } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/async_fallback.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @type {?} */\nimport * as ɵngcc0 from '@angular/core';\nconst _global = (/** @type {?} */ ((typeof window === 'undefined' ? global : window)));\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {\\@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n * @param {?} fn\n * @return {?}\n */\nfunction asyncFallback(fn) {\n    // If we're running using the Jasmine test framework, adapt to call the 'done'\n    // function when asynchronous activity is finished.\n    if (_global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return (/**\n         * @this {?}\n         * @param {?} done\n         * @return {?}\n         */\n        function (done) {\n            if (!done) {\n                // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                // fake it here and assume sync.\n                done = (/**\n                 * @return {?}\n                 */\n                function () { });\n                done.fail = (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                function (e) { throw e; });\n            }\n            runInTestZone(fn, this, done, (/**\n             * @param {?} err\n             * @return {?}\n             */\n            (err) => {\n                if (typeof err === 'string') {\n                    return done.fail(new Error(err));\n                }\n                else {\n                    done.fail(err);\n                }\n            }));\n        });\n    }\n    // Otherwise, return a promise which will resolve when asynchronous activity\n    // is finished. This will be correctly consumed by the Mocha framework with\n    // it('...', async(myFn)); or can be used in a custom framework.\n    // Not using an arrow function to preserve context passed from call site\n    return (/**\n     * @this {?}\n     * @return {?}\n     */\n    function () {\n        return new Promise((/**\n         * @param {?} finishCallback\n         * @param {?} failCallback\n         * @return {?}\n         */\n        (finishCallback, failCallback) => {\n            runInTestZone(fn, this, finishCallback, failCallback);\n        }));\n    });\n}\n/**\n * @param {?} fn\n * @param {?} context\n * @param {?} finishCallback\n * @param {?} failCallback\n * @return {?}\n */\nfunction runInTestZone(fn, context, finishCallback, failCallback) {\n    /** @type {?} */\n    const currentZone = Zone.current;\n    /** @type {?} */\n    const AsyncTestZoneSpec = ((/** @type {?} */ (Zone)))['AsyncTestZoneSpec'];\n    if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/dist/async-test.js');\n    }\n    /** @type {?} */\n    const ProxyZoneSpec = (/** @type {?} */ (((/** @type {?} */ (Zone)))['ProxyZoneSpec']));\n    if (ProxyZoneSpec === undefined) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/dist/proxy.js');\n    }\n    /** @type {?} */\n    const proxyZoneSpec = ProxyZoneSpec.get();\n    ProxyZoneSpec.assertPresent();\n    // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n    // If we do it in ProxyZone then we will get to infinite recursion.\n    /** @type {?} */\n    const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n    /** @type {?} */\n    const previousDelegate = proxyZoneSpec.getDelegate();\n    (/** @type {?} */ ((/** @type {?} */ (proxyZone)).parent)).run((/**\n     * @return {?}\n     */\n    () => {\n        /** @type {?} */\n        const testZoneSpec = new AsyncTestZoneSpec((/**\n         * @return {?}\n         */\n        () => {\n            // Need to restore the original zone.\n            currentZone.run((/**\n             * @return {?}\n             */\n            () => {\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                finishCallback();\n            }));\n        }), (/**\n         * @param {?} error\n         * @return {?}\n         */\n        (error) => {\n            // Need to restore the original zone.\n            currentZone.run((/**\n             * @return {?}\n             */\n            () => {\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                failCallback(error);\n            }));\n        }), 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n    }));\n    return Zone.current.runGuarded(fn, context);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/async.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {\\@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * \\@publicApi\n * @param {?} fn\n * @return {?}\n */\nfunction async(fn) {\n    /** @type {?} */\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return (/**\n         * @return {?}\n         */\n        function () {\n            return Promise.reject('Zone is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/dist/zone.js');\n        });\n    }\n    /** @type {?} */\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    // not using new version of zone.js\n    // TODO @JiaLiPassion, remove this after all library updated to\n    // newest version of zone.js(0.8.25)\n    return asyncFallback(fn);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/component_fixture.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Fixture for debugging and testing a component.\n *\n * \\@publicApi\n * @template T\n */\nclass ComponentFixture {\n    /**\n     * @param {?} componentRef\n     * @param {?} ngZone\n     * @param {?} _autoDetect\n     */\n    constructor(componentRef, ngZone, _autoDetect) {\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = _autoDetect;\n        this._isStable = true;\n        this._isDestroyed = false;\n        this._resolve = null;\n        this._promise = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = (/** @type {?} */ (getDebugNode(this.elementRef.nativeElement)));\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        if (ngZone) {\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\n            // of NgZone.\n            ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this._onUnstableSubscription =\n                    ngZone.onUnstable.subscribe({ next: (/**\n                         * @return {?}\n                         */\n                        () => { this._isStable = false; }) });\n                this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n                    next: (/**\n                     * @return {?}\n                     */\n                    () => {\n                        if (this._autoDetect) {\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            this.detectChanges(true);\n                        }\n                    })\n                });\n                this._onStableSubscription = ngZone.onStable.subscribe({\n                    next: (/**\n                     * @return {?}\n                     */\n                    () => {\n                        this._isStable = true;\n                        // Check whether there is a pending whenStable() completer to resolve.\n                        if (this._promise !== null) {\n                            // If so check whether there are no pending macrotasks before resolving.\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\n                            // pending macrotasks.\n                            scheduleMicroTask((/**\n                             * @return {?}\n                             */\n                            () => {\n                                if (!ngZone.hasPendingMacrotasks) {\n                                    if (this._promise !== null) {\n                                        (/** @type {?} */ (this._resolve))(true);\n                                        this._resolve = null;\n                                        this._promise = null;\n                                    }\n                                }\n                            }));\n                        }\n                    })\n                });\n                this._onErrorSubscription =\n                    ngZone.onError.subscribe({ next: (/**\n                         * @param {?} error\n                         * @return {?}\n                         */\n                        (error) => { throw error; }) });\n            }));\n        }\n    }\n    /**\n     * @private\n     * @param {?} checkNoChanges\n     * @return {?}\n     */\n    _tick(checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     * @param {?=} checkNoChanges\n     * @return {?}\n     */\n    detectChanges(checkNoChanges = true) {\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run((/**\n             * @return {?}\n             */\n            () => { this._tick(checkNoChanges); }));\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     * @return {?}\n     */\n    checkNoChanges() { this.changeDetectorRef.checkNoChanges(); }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     * @param {?=} autoDetect\n     * @return {?}\n     */\n    autoDetectChanges(autoDetect = true) {\n        if (this.ngZone == null) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     * @return {?}\n     */\n    isStable() { return this._isStable && !(/** @type {?} */ (this.ngZone)).hasPendingMacrotasks; }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     * @return {?}\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        else if (this._promise !== null) {\n            return this._promise;\n        }\n        else {\n            this._promise = new Promise((/**\n             * @param {?} res\n             * @return {?}\n             */\n            res => { this._resolve = res; }));\n            return this._promise;\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n        }\n        return (/** @type {?} */ (this._renderer));\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     * @return {?}\n     */\n    whenRenderingDone() {\n        /** @type {?} */\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     * @return {?}\n     */\n    destroy() {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            if (this._onUnstableSubscription != null) {\n                this._onUnstableSubscription.unsubscribe();\n                this._onUnstableSubscription = null;\n            }\n            if (this._onStableSubscription != null) {\n                this._onStableSubscription.unsubscribe();\n                this._onStableSubscription = null;\n            }\n            if (this._onMicrotaskEmptySubscription != null) {\n                this._onMicrotaskEmptySubscription.unsubscribe();\n                this._onMicrotaskEmptySubscription = null;\n            }\n            if (this._onErrorSubscription != null) {\n                this._onErrorSubscription.unsubscribe();\n                this._onErrorSubscription = null;\n            }\n            this._isDestroyed = true;\n        }\n    }\n}\nif (false) {\n    /**\n     * The DebugElement associated with the root element of this component.\n     * @type {?}\n     */\n    ComponentFixture.prototype.debugElement;\n    /**\n     * The instance of the root component class.\n     * @type {?}\n     */\n    ComponentFixture.prototype.componentInstance;\n    /**\n     * The native element at the root of the component.\n     * @type {?}\n     */\n    ComponentFixture.prototype.nativeElement;\n    /**\n     * The ElementRef for the element at the root of the component.\n     * @type {?}\n     */\n    ComponentFixture.prototype.elementRef;\n    /**\n     * The ChangeDetectorRef for the component\n     * @type {?}\n     */\n    ComponentFixture.prototype.changeDetectorRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._renderer;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._isStable;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._isDestroyed;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._resolve;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._promise;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._onUnstableSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._onStableSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._onMicrotaskEmptySubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._onErrorSubscription;\n    /** @type {?} */\n    ComponentFixture.prototype.componentRef;\n    /** @type {?} */\n    ComponentFixture.prototype.ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    ComponentFixture.prototype._autoDetect;\n}\n/**\n * @param {?} fn\n * @return {?}\n */\nfunction scheduleMicroTask(fn) {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/fake_async_fallback.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * fakeAsync has been moved to zone.js\n * this file is for fallback in case old version of zone.js is used\n * @type {?}\n */\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\n/** @type {?} */\nconst FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\n/** @type {?} */\nconst ProxyZoneSpec = _Zone && _Zone['ProxyZoneSpec'];\n/** @type {?} */\nlet _fakeAsyncTestZoneSpec = null;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * \\@publicApi\n * @return {?}\n */\nfunction resetFakeAsyncZoneFallback() {\n    _fakeAsyncTestZoneSpec = null;\n    // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n    ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n}\n/** @type {?} */\nlet _inFakeAsyncCall = false;\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * \\@usageNotes\n * ### Example\n *\n * {\\@example core/testing/ts/fake_async.ts region='basic'}\n *\n * \\@publicApi\n * @param {?} fn\n * @return {?} The function wrapped to be executed in the fakeAsync zone\n *\n */\nfunction fakeAsyncFallback(fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return (/**\n     * @this {?}\n     * @param {...?} args\n     * @return {?}\n     */\n    function (...args) {\n        /** @type {?} */\n        const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n        if (_inFakeAsyncCall) {\n            throw new Error('fakeAsync() calls can not be nested');\n        }\n        _inFakeAsyncCall = true;\n        try {\n            if (!_fakeAsyncTestZoneSpec) {\n                if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n            }\n            /** @type {?} */\n            let res;\n            /** @type {?} */\n            const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n            proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n            try {\n                res = fn.apply(this, args);\n                flushMicrotasksFallback();\n            }\n            finally {\n                proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n            }\n            if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n                    `periodic timer(s) still in the queue.`);\n            }\n            if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n            }\n            return res;\n        }\n        finally {\n            _inFakeAsyncCall = false;\n            resetFakeAsyncZoneFallback();\n        }\n    });\n}\n/**\n * @return {?}\n */\nfunction _getFakeAsyncZoneSpec() {\n    if (_fakeAsyncTestZoneSpec == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n    }\n    return _fakeAsyncTestZoneSpec;\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * \\@usageNotes\n * ### Example\n *\n * {\\@example core/testing/ts/fake_async.ts region='basic'}\n *\n * \\@publicApi\n * @param {?=} millis\n * @param {?=} tickOptions\n * @return {?}\n */\nfunction tickFallback(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true\n}) {\n    _getFakeAsyncZoneSpec().tick(millis, null, tickOptions);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * \\@publicApi\n * @param {?=} maxTurns\n * @return {?} The simulated time elapsed, in millis.\n *\n */\nfunction flushFallback(maxTurns) {\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * \\@publicApi\n * @return {?}\n */\nfunction discardPeriodicTasksFallback() {\n    /** @type {?} */\n    const zoneSpec = _getFakeAsyncZoneSpec();\n    zoneSpec.pendingPeriodicTimers.length = 0;\n}\n/**\n * Flush any pending microtasks.\n *\n * \\@publicApi\n * @return {?}\n */\nfunction flushMicrotasksFallback() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/fake_async.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst _Zone$1 = typeof Zone !== 'undefined' ? Zone : null;\n/** @type {?} */\nconst fakeAsyncTestModule = _Zone$1 && _Zone$1[_Zone$1.__symbol__('fakeAsyncTest')];\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * \\@publicApi\n * @return {?}\n */\nfunction resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    else {\n        return resetFakeAsyncZoneFallback();\n    }\n}\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * \\@usageNotes\n * ### Example\n *\n * {\\@example core/testing/ts/fake_async.ts region='basic'}\n *\n * \\@publicApi\n * @param {?} fn\n * @return {?} The function wrapped to be executed in the fakeAsync zone\n *\n */\nfunction fakeAsync(fn) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn);\n    }\n    else {\n        return fakeAsyncFallback(fn);\n    }\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * \\@usageNotes\n * ### Example\n *\n * {\\@example core/testing/ts/fake_async.ts region='basic'}\n *\n * \\@publicApi\n * @param {?=} millis\n * @param {?=} tickOptions\n * @return {?}\n */\nfunction tick(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true\n}) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis, tickOptions);\n    }\n    else {\n        return tickFallback(millis, tickOptions);\n    }\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * \\@publicApi\n * @param {?=} maxTurns\n * @return {?} The simulated time elapsed, in millis.\n *\n */\nfunction flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    else {\n        return flushFallback(maxTurns);\n    }\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * \\@publicApi\n * @return {?}\n */\nfunction discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    else {\n        discardPeriodicTasksFallback();\n    }\n}\n/**\n * Flush any pending microtasks.\n *\n * \\@publicApi\n * @return {?}\n */\nfunction flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    else {\n        return flushMicrotasksFallback();\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/async_test_completer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n */\nclass AsyncTestCompleter {\n    constructor() {\n        this._promise = new Promise((/**\n         * @param {?} res\n         * @param {?} rej\n         * @return {?}\n         */\n        (res, rej) => {\n            this._resolve = res;\n            this._reject = rej;\n        }));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    done(value) { this._resolve(value); }\n    /**\n     * @param {?=} error\n     * @param {?=} stackTrace\n     * @return {?}\n     */\n    fail(error, stackTrace) { this._reject(error); }\n    /**\n     * @return {?}\n     */\n    get promise() { return this._promise; }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    AsyncTestCompleter.prototype._resolve;\n    /**\n     * @type {?}\n     * @private\n     */\n    AsyncTestCompleter.prototype._reject;\n    /**\n     * @type {?}\n     * @private\n     */\n    AsyncTestCompleter.prototype._promise;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/test_bed_common.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * \\@publicApi\n */\nclass TestComponentRenderer {\n    /**\n     * @param {?} rootElementId\n     * @return {?}\n     */\n    insertRootElement(rootElementId) { }\n}\n/**\n * \\@publicApi\n * @type {?}\n */\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * \\@publicApi\n * @type {?}\n */\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n/**\n * Static methods implemented by the `TestBedViewEngine` and `TestBedRender3`\n *\n * \\@publicApi\n * @record\n */\nfunction TestBedStatic() { }\nif (false) {\n    /* Skipping unhandled member: new (...args: any[]): TestBed;*/\n    /**\n     * @param {?} ngModule\n     * @param {?} platform\n     * @param {?=} aotSummaries\n     * @return {?}\n     */\n    TestBedStatic.prototype.initTestEnvironment = function (ngModule, platform, aotSummaries) { };\n    /**\n     * Reset the providers for the test injector.\n     * @return {?}\n     */\n    TestBedStatic.prototype.resetTestEnvironment = function () { };\n    /**\n     * @return {?}\n     */\n    TestBedStatic.prototype.resetTestingModule = function () { };\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     * @param {?} config\n     * @return {?}\n     */\n    TestBedStatic.prototype.configureCompiler = function (config) { };\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     * @param {?} moduleDef\n     * @return {?}\n     */\n    TestBedStatic.prototype.configureTestingModule = function (moduleDef) { };\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     * @return {?}\n     */\n    TestBedStatic.prototype.compileComponents = function () { };\n    /**\n     * @param {?} ngModule\n     * @param {?} override\n     * @return {?}\n     */\n    TestBedStatic.prototype.overrideModule = function (ngModule, override) { };\n    /**\n     * @param {?} component\n     * @param {?} override\n     * @return {?}\n     */\n    TestBedStatic.prototype.overrideComponent = function (component, override) { };\n    /**\n     * @param {?} directive\n     * @param {?} override\n     * @return {?}\n     */\n    TestBedStatic.prototype.overrideDirective = function (directive, override) { };\n    /**\n     * @param {?} pipe\n     * @param {?} override\n     * @return {?}\n     */\n    TestBedStatic.prototype.overridePipe = function (pipe, override) { };\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @return {?}\n     */\n    TestBedStatic.prototype.overrideTemplate = function (component, template) { };\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     * @param {?} component\n     * @param {?} template\n     * @return {?}\n     */\n    TestBedStatic.prototype.overrideTemplateUsingTestingModule = function (component, template) { };\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     * @param {?} token\n     * @param {?} provider\n     * @return {?}\n     */\n    TestBedStatic.prototype.overrideProvider = function (token, provider) { };\n    /**\n     * @param {?} token\n     * @param {?} provider\n     * @return {?}\n     */\n    TestBedStatic.prototype.overrideProvider = function (token, provider) { };\n    /**\n     * @param {?} token\n     * @param {?} provider\n     * @return {?}\n     */\n    TestBedStatic.prototype.overrideProvider = function (token, provider) { };\n    /**\n     * @template T\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    TestBedStatic.prototype.inject = function (token, notFoundValue, flags) { };\n    /**\n     * @template T\n     * @param {?} token\n     * @param {?} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    TestBedStatic.prototype.inject = function (token, notFoundValue, flags) { };\n    /**\n     * @deprecated from v9.0.0 use TestBed.inject\n     * @template T\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    TestBedStatic.prototype.get = function (token, notFoundValue, flags) { };\n    /**\n     * @deprecated from v9.0.0 use TestBed.inject\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    TestBedStatic.prototype.get = function (token, notFoundValue) { };\n    /**\n     * @template T\n     * @param {?} component\n     * @return {?}\n     */\n    TestBedStatic.prototype.createComponent = function (component) { };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/src/metadata/resource_loading.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used to resolve resource URLs on `\\@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * \\@Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `\\@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `\\@Component.templateUrl` into\n * // `\\@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param {?} resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n * @return {?}\n */\nfunction resolveComponentResources(resourceResolver) {\n    // Store all promises which are fetching the resources.\n    /** @type {?} */\n    const componentResolved = [];\n    // Cache so that we don't fetch the same resource more than once.\n    /** @type {?} */\n    const urlMap = new Map();\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    function cachedResourceResolve(url) {\n        /** @type {?} */\n        let promise = urlMap.get(url);\n        if (!promise) {\n            /** @type {?} */\n            const resp = resourceResolver(url);\n            urlMap.set(url, promise = resp.then(unwrapResponse));\n        }\n        return promise;\n    }\n    componentResourceResolutionQueue.forEach((/**\n     * @param {?} component\n     * @param {?} type\n     * @return {?}\n     */\n    (component, type) => {\n        /** @type {?} */\n        const promises = [];\n        if (component.templateUrl) {\n            promises.push(cachedResourceResolve(component.templateUrl).then((/**\n             * @param {?} template\n             * @return {?}\n             */\n            (template) => {\n                component.template = template;\n            })));\n        }\n        /** @type {?} */\n        const styleUrls = component.styleUrls;\n        /** @type {?} */\n        const styles = component.styles || (component.styles = []);\n        /** @type {?} */\n        const styleOffset = component.styles.length;\n        styleUrls && styleUrls.forEach((/**\n         * @param {?} styleUrl\n         * @param {?} index\n         * @return {?}\n         */\n        (styleUrl, index) => {\n            styles.push(''); // pre-allocate array.\n            promises.push(cachedResourceResolve(styleUrl).then((/**\n             * @param {?} style\n             * @return {?}\n             */\n            (style) => {\n                styles[styleOffset + index] = style;\n                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n                if (styleUrls.length == 0) {\n                    component.styleUrls = undefined;\n                }\n            })));\n        }));\n        /** @type {?} */\n        const fullyResolved = Promise.all(promises).then((/**\n         * @return {?}\n         */\n        () => componentDefResolved(type)));\n        componentResolved.push(fullyResolved);\n    }));\n    clearResolutionOfComponentResourcesQueue();\n    return Promise.all(componentResolved).then((/**\n     * @return {?}\n     */\n    () => undefined));\n}\n/** @type {?} */\nlet componentResourceResolutionQueue = new Map();\n// Track when existing ɵcmp for a Type is waiting on resources.\n/** @type {?} */\nconst componentDefPendingResolution = new Set();\n/**\n * @param {?} type\n * @param {?} metadata\n * @return {?}\n */\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n    if (componentNeedsResolution(metadata)) {\n        componentResourceResolutionQueue.set(type, metadata);\n        componentDefPendingResolution.add(type);\n    }\n}\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isComponentDefPendingResolution(type) {\n    return componentDefPendingResolution.has(type);\n}\n/**\n * @param {?} component\n * @return {?}\n */\nfunction componentNeedsResolution(component) {\n    return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\n        component.styleUrls && component.styleUrls.length);\n}\n/**\n * @return {?}\n */\nfunction clearResolutionOfComponentResourcesQueue() {\n    /** @type {?} */\n    const old = componentResourceResolutionQueue;\n    componentResourceResolutionQueue = new Map();\n    return old;\n}\n/**\n * @param {?} queue\n * @return {?}\n */\nfunction restoreComponentResolutionQueue(queue) {\n    componentDefPendingResolution.clear();\n    queue.forEach((/**\n     * @param {?} _\n     * @param {?} type\n     * @return {?}\n     */\n    (_, type) => componentDefPendingResolution.add(type)));\n    componentResourceResolutionQueue = queue;\n}\n/**\n * @return {?}\n */\nfunction isComponentResourceResolutionQueueEmpty() {\n    return componentResourceResolutionQueue.size === 0;\n}\n/**\n * @param {?} response\n * @return {?}\n */\nfunction unwrapResponse(response) {\n    return typeof response == 'string' ? response : response.text();\n}\n/**\n * @param {?} type\n * @return {?}\n */\nfunction componentDefResolved(type) {\n    componentDefPendingResolution.delete(type);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/metadata_overrider.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    constructor() {\n        this._references = new Map();\n    }\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     * @template C, T\n     * @param {?} metadataClass\n     * @param {?} oldMetadata\n     * @param {?} override\n     * @return {?}\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        /** @type {?} */\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((/**\n             * @param {?} prop\n             * @return {?}\n             */\n            (prop) => props[prop] = ((/** @type {?} */ (oldMetadata)))[prop]));\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass((/** @type {?} */ (props)));\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MetadataOverrider.prototype._references;\n}\n/**\n * @param {?} metadata\n * @param {?} remove\n * @param {?} references\n * @return {?}\n */\nfunction removeMetadata(metadata, remove, references) {\n    /** @type {?} */\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        /** @type {?} */\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((/**\n             * @param {?} value\n             * @return {?}\n             */\n            (value) => { removeObjects.add(_propHashKey(prop, value, references)); }));\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        /** @type {?} */\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((/**\n             * @param {?} value\n             * @return {?}\n             */\n            (value) => !removeObjects.has(_propHashKey(prop, value, references))));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\n/**\n * @param {?} metadata\n * @param {?} add\n * @return {?}\n */\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        /** @type {?} */\n        const addValue = add[prop];\n        /** @type {?} */\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\n/**\n * @param {?} metadata\n * @param {?} set\n * @return {?}\n */\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\n/**\n * @param {?} propName\n * @param {?} propValue\n * @param {?} references\n * @return {?}\n */\nfunction _propHashKey(propName, propValue, references) {\n    /** @type {?} */\n    const replacer = (/**\n     * @param {?} key\n     * @param {?} value\n     * @return {?}\n     */\n    (key, value) => {\n        if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    });\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\n/**\n * @param {?} ref\n * @param {?} references\n * @return {?}\n */\nfunction _serializeReference(ref, references) {\n    /** @type {?} */\n    let id = references.get(ref);\n    if (!id) {\n        id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _valueProps(obj) {\n    /** @type {?} */\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    (prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    }));\n    // getters\n    /** @type {?} */\n    let proto = obj;\n    while (proto = Object.getPrototypeOf(proto)) {\n        Object.keys(proto).forEach((/**\n         * @param {?} protoProp\n         * @return {?}\n         */\n        (protoProp) => {\n            /** @type {?} */\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        }));\n    }\n    return props;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/resolvers.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst reflection = new ɵReflectionCapabilities();\n/**\n * Base interface to resolve `\\@Component`, `\\@Directive`, `\\@Pipe` and `\\@NgModule`.\n * @record\n * @template T\n */\nfunction Resolver() { }\nif (false) {\n    /**\n     * @param {?} type\n     * @param {?} override\n     * @return {?}\n     */\n    Resolver.prototype.addOverride = function (type, override) { };\n    /**\n     * @param {?} overrides\n     * @return {?}\n     */\n    Resolver.prototype.setOverrides = function (overrides) { };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    Resolver.prototype.resolve = function (type) { };\n}\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n * @abstract\n * @template T\n */\nclass OverrideResolver {\n    constructor() {\n        this.overrides = new Map();\n        this.resolved = new Map();\n    }\n    /**\n     * @param {?} type\n     * @param {?} override\n     * @return {?}\n     */\n    addOverride(type, override) {\n        /** @type {?} */\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    /**\n     * @param {?} overrides\n     * @return {?}\n     */\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ([type, override]) => { this.addOverride(type, override); }));\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    getAnnotation(type) {\n        /** @type {?} */\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            /** @type {?} */\n            const annotation = annotations[i];\n            /** @type {?} */\n            const isKnownType = annotation instanceof Directive || annotation instanceof Component ||\n                annotation instanceof Pipe || annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    resolve(type) {\n        /** @type {?} */\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                /** @type {?} */\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    /** @type {?} */\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach((/**\n                     * @param {?} override\n                     * @return {?}\n                     */\n                    override => {\n                        resolved = overrider.overrideMetadata(this.type, (/** @type {?} */ (resolved)), override);\n                    }));\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    OverrideResolver.prototype.overrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    OverrideResolver.prototype.resolved;\n    /**\n     * @abstract\n     * @return {?}\n     */\n    OverrideResolver.prototype.type = function () { };\n}\nclass DirectiveResolver extends OverrideResolver {\n    /**\n     * @return {?}\n     */\n    get type() { return Directive; }\n}\nclass ComponentResolver extends OverrideResolver {\n    /**\n     * @return {?}\n     */\n    get type() { return Component; }\n}\nclass PipeResolver extends OverrideResolver {\n    /**\n     * @return {?}\n     */\n    get type() { return Pipe; }\n}\nclass NgModuleResolver extends OverrideResolver {\n    /**\n     * @return {?}\n     */\n    get type() { return NgModule; }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/r3_test_bed_compiler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst TestingModuleOverride = {\n    DECLARATION: 0,\n    OVERRIDE_TEMPLATE: 1,\n};\nTestingModuleOverride[TestingModuleOverride.DECLARATION] = 'DECLARATION';\nTestingModuleOverride[TestingModuleOverride.OVERRIDE_TEMPLATE] = 'OVERRIDE_TEMPLATE';\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isTestingModuleOverride(value) {\n    return value === TestingModuleOverride.DECLARATION ||\n        value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\n/**\n * @record\n */\nfunction CleanupOperation() { }\nif (false) {\n    /** @type {?} */\n    CleanupOperation.prototype.fieldName;\n    /** @type {?} */\n    CleanupOperation.prototype.object;\n    /** @type {?} */\n    CleanupOperation.prototype.originalValue;\n}\nclass R3TestBedCompiler {\n    /**\n     * @param {?} platform\n     * @param {?} additionalModuleTypes\n     */\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        this.originalComponentResolutionQueue = null;\n        // Testing module configuration\n        this.declarations = [];\n        this.imports = [];\n        this.providers = [];\n        this.schemas = [];\n        // Queues of components/directives/pipes that should be recompiled.\n        this.pendingComponents = new Set();\n        this.pendingDirectives = new Set();\n        this.pendingPipes = new Set();\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\n        this.seenComponents = new Set();\n        this.seenDirectives = new Set();\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\n        // defined at the same time.\n        this.existingComponentStyles = new Map();\n        this.resolvers = initResolvers();\n        this.componentToModuleScope = new Map();\n        // Map that keeps initial version of component/directive/pipe defs in case\n        // we compile a Type again, thus overriding respective static fields. This is\n        // required to make sure we restore defs to their initial states between test runs\n        // TODO: we should support the case with multiple defs on a type\n        this.initialNgDefs = new Map();\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n        // defs in case TestBed makes changes to the originals.\n        this.defCleanupOps = [];\n        this._injector = null;\n        this.compilerProviders = null;\n        this.providerOverrides = [];\n        this.rootProviderOverrides = [];\n        // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n        // module's provider list.\n        this.providerOverridesByModule = new Map();\n        this.providerOverridesByToken = new Map();\n        this.moduleProvidersOverridden = new Set();\n        this.testModuleRef = null;\n        this.hasModuleOverrides = false;\n        class DynamicTestModule {\n        }\n        this.testModuleType = (/** @type {?} */ (DynamicTestModule));\n    }\n    /**\n     * @param {?} providers\n     * @return {?}\n     */\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    /**\n     * @param {?} moduleDef\n     * @return {?}\n     */\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} override\n     * @return {?}\n     */\n    overrideModule(ngModule, override) {\n        this.hasModuleOverrides = true;\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        /** @type {?} */\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    /**\n     * @param {?} component\n     * @param {?} override\n     * @return {?}\n     */\n    overrideComponent(component, override) {\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n    }\n    /**\n     * @param {?} directive\n     * @param {?} override\n     * @return {?}\n     */\n    overrideDirective(directive, override) {\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    /**\n     * @param {?} pipe\n     * @param {?} override\n     * @return {?}\n     */\n    overridePipe(pipe, override) {\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    /**\n     * @param {?} token\n     * @param {?} provider\n     * @return {?}\n     */\n    overrideProvider(token, provider) {\n        /** @type {?} */\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        /** @type {?} */\n        const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n        /** @type {?} */\n        const isRoot = injectableDef !== null && injectableDef.providedIn === 'root';\n        /** @type {?} */\n        const overridesBucket = isRoot ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && injectableDef.providedIn !== null &&\n            typeof injectableDef.providedIn !== 'string') {\n            /** @type {?} */\n            const existingOverrides = this.providerOverridesByModule.get(injectableDef.providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(injectableDef.providedIn, [providerDef]);\n            }\n        }\n    }\n    /**\n     * @param {?} type\n     * @param {?} template\n     * @return {?}\n     */\n    overrideTemplateUsingTestingModule(type, template) {\n        /** @type {?} */\n        const def = ((/** @type {?} */ (type)))[ɵNG_COMP_DEF];\n        /** @type {?} */\n        const hasStyleUrls = (/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const metadata = (/** @type {?} */ ((/** @type {?} */ (this.resolvers.component.resolve(type)))));\n            return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n        });\n        /** @type {?} */\n        const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        /** @type {?} */\n        const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    /**\n     * @return {?}\n     */\n    compileComponents() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.clearComponentResolutionQueue();\n            // Run compilers for all queued types.\n            /** @type {?} */\n            let needsAsyncResources = this.compileTypesSync();\n            // compileComponents() should not be async unless it needs to be.\n            if (needsAsyncResources) {\n                /** @type {?} */\n                let resourceLoader;\n                /** @type {?} */\n                let resolver = (/**\n                 * @param {?} url\n                 * @return {?}\n                 */\n                (url) => {\n                    if (!resourceLoader) {\n                        resourceLoader = this.injector.get(ResourceLoader);\n                    }\n                    return Promise.resolve(resourceLoader.get(url));\n                });\n                yield resolveComponentResources(resolver);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        /** @type {?} */\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        ((/** @type {?} */ (this.testModuleRef.injector.get(ApplicationInitStatus)))).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        /** @type {?} */\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\n        ɵsetLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * \\@internal\n     * @param {?} moduleType\n     * @return {?}\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesToModule(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * \\@internal\n     * @param {?} moduleType\n     * @return {?}\n     */\n    _compileNgModuleAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.queueTypesFromModulesArray([moduleType]);\n            yield this.compileComponents();\n            this.applyProviderOverrides();\n            this.applyProviderOverridesToModule(moduleType);\n            this.applyTransitiveScopes();\n        });\n    }\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    _getModuleResolver() { return this.resolvers.module; }\n    /**\n     * \\@internal\n     * @param {?} moduleType\n     * @return {?}\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((/**\n         * @param {?} factories\n         * @param {?} declaration\n         * @return {?}\n         */\n        (factories, declaration) => {\n            /** @type {?} */\n            const componentDef = ((/** @type {?} */ (declaration))).ɵcmp;\n            componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, (/** @type {?} */ (this.testModuleRef))));\n            return factories;\n        }), (/** @type {?} */ ([])));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        /** @type {?} */\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach((/**\n         * @param {?} declaration\n         * @return {?}\n         */\n        declaration => {\n            needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n            /** @type {?} */\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n            ɵcompileComponent(declaration, metadata);\n        }));\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach((/**\n         * @param {?} declaration\n         * @return {?}\n         */\n        declaration => {\n            /** @type {?} */\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n            ɵcompileDirective(declaration, metadata);\n        }));\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach((/**\n         * @param {?} declaration\n         * @return {?}\n         */\n        declaration => {\n            /** @type {?} */\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n            ɵcompilePipe(declaration, metadata);\n        }));\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    applyTransitiveScopes() {\n        /** @type {?} */\n        const moduleToScope = new Map();\n        /** @type {?} */\n        const getScopeOfModule = (/**\n         * @param {?} moduleType\n         * @return {?}\n         */\n        (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                /** @type {?} */\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                /** @type {?} */\n                const realType = isTestingModule ? this.testModuleType : (/** @type {?} */ (moduleType));\n                // Module overrides (via TestBed.overrideModule) might affect scopes that were\n                // previously calculated and stored in `transitiveCompileScopes`. If module overrides\n                // are present, always re-calculate transitive scopes to have the most up-to-date\n                // information available. The `moduleToScope` map avoids repeated re-calculation of\n                // scopes for the same module.\n                if (!isTestingModule && this.hasModuleOverrides) {\n                    this.storeFieldOfDefOnType((/** @type {?} */ (moduleType)), ɵNG_MOD_DEF, 'transitiveCompileScopes');\n                    ((/** @type {?} */ (moduleType)))[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n                }\n                moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n            }\n            return (/** @type {?} */ (moduleToScope.get(moduleType)));\n        });\n        this.componentToModuleScope.forEach((/**\n         * @param {?} moduleType\n         * @param {?} componentType\n         * @return {?}\n         */\n        (moduleType, componentType) => {\n            /** @type {?} */\n            const moduleScope = getScopeOfModule(moduleType);\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs');\n            ɵpatchComponentDefWithScope(((/** @type {?} */ (componentType))).ɵcmp, moduleScope);\n        }));\n        this.componentToModuleScope.clear();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    applyProviderOverrides() {\n        /** @type {?} */\n        const maybeApplyOverrides = (/**\n         * @param {?} field\n         * @return {?}\n         */\n        (field) => (/**\n         * @param {?} type\n         * @return {?}\n         */\n        (type) => {\n            /** @type {?} */\n            const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            /** @type {?} */\n            const metadata = (/** @type {?} */ (resolver.resolve(type)));\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        }));\n        this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    /**\n     * @private\n     * @param {?} moduleType\n     * @return {?}\n     */\n    applyProviderOverridesToModule(moduleType) {\n        if (this.moduleProvidersOverridden.has(moduleType)) {\n            return;\n        }\n        this.moduleProvidersOverridden.add(moduleType);\n        /** @type {?} */\n        const injectorDef = ((/** @type {?} */ (moduleType)))[ɵNG_INJ_DEF];\n        if (this.providerOverridesByToken.size > 0) {\n            /** @type {?} */\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get((/** @type {?} */ (moduleType))) || [])\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(ɵNG_INJ_DEF, moduleType);\n                this.storeFieldOfDefOnType(moduleType, ɵNG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            /** @type {?} */\n            const moduleDef = ((/** @type {?} */ (moduleType)))[ɵNG_MOD_DEF];\n            /** @type {?} */\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesToModule(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((/**\n         * @param {?} styles\n         * @param {?} type\n         * @return {?}\n         */\n        (styles, type) => ((/** @type {?} */ (type)))[ɵNG_COMP_DEF].styles = styles));\n        this.existingComponentStyles.clear();\n    }\n    /**\n     * @private\n     * @param {?} arr\n     * @param {?} moduleType\n     * @return {?}\n     */\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} metadata\n     * @return {?}\n     */\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n        ɵcompileNgModuleDefs((/** @type {?} */ (ngModule)), metadata);\n    }\n    /**\n     * @private\n     * @param {?} type\n     * @param {?} moduleType\n     * @return {?}\n     */\n    queueType(type, moduleType) {\n        /** @type {?} */\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            if (!this.componentToModuleScope.has(type) ||\n                this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        /** @type {?} */\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        /** @type {?} */\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    /**\n     * @private\n     * @param {?} arr\n     * @return {?}\n     */\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule while processing the imports and exports of an\n        // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n        // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n        /** @type {?} */\n        const processedNgModuleDefs = new Set();\n        /** @type {?} */\n        const queueTypesFromModulesArrayRecur = (/**\n         * @param {?} arr\n         * @return {?}\n         */\n        (arr) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    /** @type {?} */\n                    const def = value.ɵmod;\n                    if (processedNgModuleDefs.has(def)) {\n                        continue;\n                    }\n                    processedNgModuleDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n            }\n        });\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    /**\n     * @private\n     * @param {?} prop\n     * @param {?} type\n     * @return {?}\n     */\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            /** @type {?} */\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            this.initialNgDefs.set(type, [prop, currentDef]);\n        }\n    }\n    /**\n     * @private\n     * @param {?} type\n     * @param {?} defField\n     * @param {?} fieldName\n     * @return {?}\n     */\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        /** @type {?} */\n        const def = ((/** @type {?} */ (type)))[defField];\n        /** @type {?} */\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     * @private\n     * @return {?}\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        clearResolutionOfComponentResourcesQueue().forEach((/**\n         * @param {?} value\n         * @param {?} key\n         * @return {?}\n         */\n        (value, key) => (/** @type {?} */ (this.originalComponentResolutionQueue)).set(key, value)));\n    }\n    /*\n       * Restores component resolution queue to the previously saved state. This operation is performed\n       * as a part of restoring the state after completion of the current set of tests (that might\n       * potentially mutate the state).\n       */\n    /**\n     * @private\n     * @return {?}\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (/**\n         * @param {?} op\n         * @return {?}\n         */\n        (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        }));\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((/**\n         * @param {?} value\n         * @param {?} type\n         * @return {?}\n         */\n        (value, type) => {\n            const [prop, descriptor] = value;\n            if (!descriptor) {\n                // Delete operations are generally undesirable since they have performance implications\n                // on objects they were applied to. In this particular case, situations where this code\n                // is invoked should be quite rare to cause any noticeable impact, since it's applied\n                // only to some test cases (for example when class with no annotations extends some\n                // @Component) when we need to clear 'ɵcmp' field on a given class to restore\n                // its original state (before applying overrides and running tests).\n                delete ((/** @type {?} */ (type)))[prop];\n            }\n            else {\n                Object.defineProperty(type, prop, descriptor);\n            }\n        }));\n        this.initialNgDefs.clear();\n        this.moduleProvidersOverridden.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        ɵcompileNgModuleDefs((/** @type {?} */ (RootScopeModule)), {\n            providers: [...this.rootProviderOverrides],\n        });\n        /** @type {?} */\n        const ngZone = new NgZone({ enableLongStackTrace: true });\n        /** @type {?} */\n        const providers = [\n            { provide: NgZone, useValue: ngZone },\n            { provide: Compiler, useFactory: (/**\n                 * @return {?}\n                 */\n                () => new R3TestCompiler(this)) },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        /** @type {?} */\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        // clang-format off\n        ɵcompileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, /* allowDuplicateDeclarationsInRoot */ true);\n        // clang-format on\n        this.applyProviderOverridesToModule(this.testModuleType);\n    }\n    /**\n     * @return {?}\n     */\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        /** @type {?} */\n        const providers = [];\n        /** @type {?} */\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n        compilerOptions.forEach((/**\n         * @param {?} opts\n         * @return {?}\n         */\n        opts => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        }));\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n        class CompilerModule {\n        }\n        ɵcompileNgModuleDefs((/** @type {?} */ (CompilerModule)), { providers });\n        /** @type {?} */\n        const CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n        this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    /**\n     * @private\n     * @param {?} provider\n     * @return {?}\n     */\n    getSingleProviderOverrides(provider) {\n        /** @type {?} */\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    /**\n     * @private\n     * @param {?=} providers\n     * @return {?}\n     */\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flatten() operates on the metadata's\n        // providers and applies a mapping function which retrieves overrides for each incoming\n        // provider. The outer flatten() then flattens the produced overrides array. If this is not\n        // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flatten(providers, (/**\n         * @param {?} provider\n         * @return {?}\n         */\n        (provider) => this.getSingleProviderOverrides(provider) || [])));\n    }\n    /**\n     * @private\n     * @param {?=} providers\n     * @return {?}\n     */\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        /** @type {?} */\n        const flattenedProviders = flatten(providers);\n        /** @type {?} */\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        /** @type {?} */\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        /** @type {?} */\n        const final = [];\n        /** @type {?} */\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (/**\n         * @param {?} provider\n         * @return {?}\n         */\n        (provider) => {\n            /** @type {?} */\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift(Object.assign(Object.assign({}, provider), { multi: false }));\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        }));\n        return final;\n    }\n    /**\n     * @private\n     * @param {?=} providers\n     * @return {?}\n     */\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    /**\n     * @private\n     * @param {?} declaration\n     * @param {?} field\n     * @return {?}\n     */\n    patchDefWithProviderOverrides(declaration, field) {\n        /** @type {?} */\n        const def = ((/** @type {?} */ (declaration)))[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            /** @type {?} */\n            const resolver = def.providersResolver;\n            /** @type {?} */\n            const processProvidersFn = (/**\n             * @param {?} providers\n             * @return {?}\n             */\n            (providers) => this.getOverriddenProviders(providers));\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (/**\n             * @param {?} ngDef\n             * @return {?}\n             */\n            (ngDef) => resolver(ngDef, processProvidersFn));\n        }\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.originalComponentResolutionQueue;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.declarations;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.imports;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.providers;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.schemas;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.pendingComponents;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.pendingDirectives;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.pendingPipes;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.seenComponents;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.seenDirectives;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.existingComponentStyles;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.resolvers;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.componentToModuleScope;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.initialNgDefs;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.defCleanupOps;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype._injector;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.compilerProviders;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.providerOverrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.rootProviderOverrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.providerOverridesByModule;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.providerOverridesByToken;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.moduleProvidersOverridden;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.testModuleType;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.testModuleRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.hasModuleOverrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.platform;\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestBedCompiler.prototype.additionalModuleTypes;\n}\n/**\n * @return {?}\n */\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver()\n    };\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('ɵmod');\n}\n/**\n * @template T\n * @param {?} maybeFn\n * @return {?}\n */\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n/**\n * @template T\n * @param {?} values\n * @param {?=} mapFn\n * @return {?}\n */\nfunction flatten(values, mapFn) {\n    /** @type {?} */\n    const out = [];\n    values.forEach((/**\n     * @param {?} value\n     * @return {?}\n     */\n    value => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value, mapFn));\n        }\n        else {\n            out.push(mapFn ? mapFn(value) : value);\n        }\n    }));\n    return out;\n}\n/**\n * @param {?} provider\n * @param {?} field\n * @return {?}\n */\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && ((/** @type {?} */ (provider)))[field];\n}\n/**\n * @param {?} provider\n * @return {?}\n */\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\n/**\n * @template T\n * @param {?} values\n * @param {?} fn\n * @return {?}\n */\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\n/**\n * @param {?} name\n * @param {?} expectedType\n * @return {?}\n */\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    /**\n     * @param {?} testBed\n     */\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new ɵNgModuleFactory(moduleType);\n    }\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    compileModuleAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.testBed._compileNgModuleAsync(moduleType);\n            return new ɵNgModuleFactory(moduleType);\n        });\n    }\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    compileModuleAndAllComponentsSync(moduleType) {\n        /** @type {?} */\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        /** @type {?} */\n        const componentFactories = this.testBed._getComponentFactories((/** @type {?} */ (moduleType)));\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    compileModuleAndAllComponentsAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            /** @type {?} */\n            const ngModuleFactory = yield this.compileModuleAsync(moduleType);\n            /** @type {?} */\n            const componentFactories = this.testBed._getComponentFactories((/** @type {?} */ (moduleType)));\n            return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n        });\n    }\n    /**\n     * @return {?}\n     */\n    clearCache() { }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    clearCacheFor(type) { }\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    getModuleId(moduleType) {\n        /** @type {?} */\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return meta && meta.id || undefined;\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    R3TestCompiler.prototype.testBed;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/r3_test_bed.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nlet _nextRootElementId = 0;\n/**\n * \\@description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nclass TestBedRender3 {\n    constructor() {\n        // Properties\n        this.platform = (/** @type {?} */ (null));\n        this.ngModule = (/** @type {?} */ (null));\n        this._compiler = null;\n        this._testModuleRef = null;\n        this._activeFixtures = [];\n        this._globalCompilationChecked = false;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '\\@angular/<platform_name>/testing'.\n     *\n     * \\@publicApi\n     * @param {?} ngModule\n     * @param {?} platform\n     * @param {?=} aotSummaries\n     * @return {?}\n     */\n    static initTestEnvironment(ngModule, platform, aotSummaries) {\n        /** @type {?} */\n        const testBed = _getTestBedRender3();\n        testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * \\@publicApi\n     * @return {?}\n     */\n    static resetTestEnvironment() { _getTestBedRender3().resetTestEnvironment(); }\n    /**\n     * @param {?} config\n     * @return {?}\n     */\n    static configureCompiler(config) {\n        _getTestBedRender3().configureCompiler(config);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     * @param {?} moduleDef\n     * @return {?}\n     */\n    static configureTestingModule(moduleDef) {\n        _getTestBedRender3().configureTestingModule(moduleDef);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     * @return {?}\n     */\n    static compileComponents() { return _getTestBedRender3().compileComponents(); }\n    /**\n     * @param {?} ngModule\n     * @param {?} override\n     * @return {?}\n     */\n    static overrideModule(ngModule, override) {\n        _getTestBedRender3().overrideModule(ngModule, override);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * @param {?} component\n     * @param {?} override\n     * @return {?}\n     */\n    static overrideComponent(component, override) {\n        _getTestBedRender3().overrideComponent(component, override);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * @param {?} directive\n     * @param {?} override\n     * @return {?}\n     */\n    static overrideDirective(directive, override) {\n        _getTestBedRender3().overrideDirective(directive, override);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * @param {?} pipe\n     * @param {?} override\n     * @return {?}\n     */\n    static overridePipe(pipe, override) {\n        _getTestBedRender3().overridePipe(pipe, override);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @return {?}\n     */\n    static overrideTemplate(component, template) {\n        _getTestBedRender3().overrideComponent(component, { set: { template, templateUrl: (/** @type {?} */ (null)) } });\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     * @param {?} component\n     * @param {?} template\n     * @return {?}\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * @param {?} token\n     * @param {?} provider\n     * @return {?}\n     */\n    static overrideProvider(token, provider) {\n        _getTestBedRender3().overrideProvider(token, provider);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * @template T\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    static inject(token, notFoundValue, flags) {\n        return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    /**\n     * @deprecated from v9.0.0 use TestBed.inject\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    /**\n     * @template T\n     * @param {?} component\n     * @return {?}\n     */\n    static createComponent(component) {\n        return _getTestBedRender3().createComponent(component);\n    }\n    /**\n     * @return {?}\n     */\n    static resetTestingModule() {\n        _getTestBedRender3().resetTestingModule();\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '\\@angular/<platform_name>/testing'.\n     *\n     * \\@publicApi\n     * @param {?} ngModule\n     * @param {?} platform\n     * @param {?=} aotSummaries\n     * @return {?}\n     */\n    initTestEnvironment(ngModule, platform, aotSummaries) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * \\@publicApi\n     * @return {?}\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = (/** @type {?} */ (null));\n        this.ngModule = (/** @type {?} */ (null));\n    }\n    /**\n     * @return {?}\n     */\n    resetTestingModule() {\n        this.checkGlobalCompilationFinished();\n        ɵresetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n        this._testModuleRef = null;\n        this.destroyActiveFixtures();\n    }\n    /**\n     * @param {?} config\n     * @return {?}\n     */\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('the Render3 compiler JiT mode is not configurable !');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n    }\n    /**\n     * @param {?} moduleDef\n     * @return {?}\n     */\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\n        this.compiler.configureTestingModule(moduleDef);\n    }\n    /**\n     * @return {?}\n     */\n    compileComponents() { return this.compiler.compileComponents(); }\n    /**\n     * @template T\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    inject(token, notFoundValue, flags) {\n        if ((/** @type {?} */ (token)) === TestBedRender3) {\n            return (/** @type {?} */ (this));\n        }\n        /** @type {?} */\n        const UNDEFINED = {};\n        /** @type {?} */\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n        return result === UNDEFINED ? (/** @type {?} */ (this.compiler.injector.get(token, notFoundValue, flags))) :\n            result;\n    }\n    /**\n     * @deprecated from v9.0.0 use TestBed.inject\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    /**\n     * @param {?} tokens\n     * @param {?} fn\n     * @param {?=} context\n     * @return {?}\n     */\n    execute(tokens, fn, context) {\n        /** @type {?} */\n        const params = tokens.map((/**\n         * @param {?} t\n         * @return {?}\n         */\n        t => this.inject(t)));\n        return fn.apply(context, params);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} override\n     * @return {?}\n     */\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n    }\n    /**\n     * @param {?} component\n     * @param {?} override\n     * @return {?}\n     */\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @return {?}\n     */\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n    }\n    /**\n     * @param {?} directive\n     * @param {?} override\n     * @return {?}\n     */\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n    }\n    /**\n     * @param {?} pipe\n     * @param {?} override\n     * @return {?}\n     */\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     * @param {?} token\n     * @param {?} provider\n     * @return {?}\n     */\n    overrideProvider(token, provider) {\n        this.compiler.overrideProvider(token, provider);\n    }\n    /**\n     * @template T\n     * @param {?} type\n     * @return {?}\n     */\n    createComponent(type) {\n        /** @type {?} */\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        /** @type {?} */\n        const rootElId = `root-ng-internal-isolated-${_nextRootElementId++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        /** @type {?} */\n        const componentDef = ((/** @type {?} */ (type))).ɵcmp;\n        if (!componentDef) {\n            throw new Error(`It looks like '${ɵstringify(type)}' has not been IVY compiled - it has no 'ɵcmp' field`);\n        }\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        /** @type {?} */\n        const noNgZone = this.inject((/** @type {?} */ (ComponentFixtureNoNgZone)), false);\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        /** @type {?} */\n        const autoDetect = this.inject((/** @type {?} */ (ComponentFixtureAutoDetect)), false);\n        /** @type {?} */\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        /** @type {?} */\n        const componentFactory = new ɵRender3ComponentFactory(componentDef);\n        /** @type {?} */\n        const initComponent = (/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        });\n        /** @type {?} */\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * \\@internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     * @private\n     * @return {?}\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * \\@internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     * @private\n     * @return {?}\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    /**\n     * @private\n     * @param {?} methodName\n     * @param {?} methodDescription\n     * @return {?}\n     */\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     * @private\n     * @return {?}\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this._globalCompilationChecked && this._testModuleRef === null) {\n            ɵflushModuleScopingQueueAsMuchAsPossible();\n        }\n        this._globalCompilationChecked = true;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    destroyActiveFixtures() {\n        this._activeFixtures.forEach((/**\n         * @param {?} fixture\n         * @return {?}\n         */\n        (fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        }));\n        this._activeFixtures = [];\n    }\n}\nif (false) {\n    /** @type {?} */\n    TestBedRender3.prototype.platform;\n    /** @type {?} */\n    TestBedRender3.prototype.ngModule;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedRender3.prototype._compiler;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedRender3.prototype._testModuleRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedRender3.prototype._activeFixtures;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedRender3.prototype._globalCompilationChecked;\n}\n/** @type {?} */\nlet testBed;\n/**\n * @return {?}\n */\nfunction _getTestBedRender3() {\n    return testBed = testBed || new TestBedRender3();\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/test_compiler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @return {?}\n */\nfunction unimplemented() {\n    throw Error('unimplemented');\n}\n/**\n * Special interface to the compiler only used by testing\n *\n * \\@publicApi\n */\nclass TestingCompiler extends Compiler {\n    /**\n     * @return {?}\n     */\n    get injector() { throw unimplemented(); }\n    /**\n     * @param {?} module\n     * @param {?} overrides\n     * @return {?}\n     */\n    overrideModule(module, overrides) {\n        throw unimplemented();\n    }\n    /**\n     * @param {?} directive\n     * @param {?} overrides\n     * @return {?}\n     */\n    overrideDirective(directive, overrides) {\n        throw unimplemented();\n    }\n    /**\n     * @param {?} component\n     * @param {?} overrides\n     * @return {?}\n     */\n    overrideComponent(component, overrides) {\n        throw unimplemented();\n    }\n    /**\n     * @param {?} directive\n     * @param {?} overrides\n     * @return {?}\n     */\n    overridePipe(directive, overrides) {\n        throw unimplemented();\n    }\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     * @param {?} summaries\n     * @return {?}\n     */\n    loadAotSummaries(summaries) { throw unimplemented(); }\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     * @template T\n     * @param {?} component\n     * @return {?}\n     */\n    getComponentFactory(component) { throw unimplemented(); }\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     * @param {?} error\n     * @return {?}\n     */\n    getComponentFromError(error) { throw unimplemented(); }\n}\nTestingCompiler.ɵfac = function TestingCompiler_Factory(t) { return ɵTestingCompiler_BaseFactory(t || TestingCompiler); };\nTestingCompiler.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TestingCompiler, factory: TestingCompiler.ɵfac });\nconst ɵTestingCompiler_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TestingCompiler);\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TestingCompiler, [{\n        type: Injectable\n    }], null, null); })();\n/**\n * A factory for creating a Compiler\n *\n * \\@publicApi\n * @abstract\n */\nclass TestingCompilerFactory {\n}\nif (false) {\n    /**\n     * @abstract\n     * @param {?=} options\n     * @return {?}\n     */\n    TestingCompilerFactory.prototype.createTestingCompiler = function (options) { };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/test_bed.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nlet _nextRootElementId$1 = 0;\n// WARNING: interface has both a type and a value, skipping emit\n/**\n * \\@description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nclass TestBedViewEngine {\n    constructor() {\n        this._instantiated = false;\n        this._compiler = (/** @type {?} */ (null));\n        this._moduleRef = (/** @type {?} */ (null));\n        this._moduleFactory = (/** @type {?} */ (null));\n        this._compilerOptions = [];\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._activeFixtures = [];\n        this._testEnvAotSummaries = (/**\n         * @return {?}\n         */\n        () => []);\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this.platform = (/** @type {?} */ (null));\n        this.ngModule = (/** @type {?} */ (null));\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '\\@angular/<platform_name>/testing'.\n     * @param {?} ngModule\n     * @param {?} platform\n     * @param {?=} aotSummaries\n     * @return {?}\n     */\n    static initTestEnvironment(ngModule, platform, aotSummaries) {\n        /** @type {?} */\n        const testBed = _getTestBedViewEngine();\n        testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     * @return {?}\n     */\n    static resetTestEnvironment() { _getTestBedViewEngine().resetTestEnvironment(); }\n    /**\n     * @return {?}\n     */\n    static resetTestingModule() {\n        _getTestBedViewEngine().resetTestingModule();\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     * @param {?} config\n     * @return {?}\n     */\n    static configureCompiler(config) {\n        _getTestBedViewEngine().configureCompiler(config);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     * @param {?} moduleDef\n     * @return {?}\n     */\n    static configureTestingModule(moduleDef) {\n        _getTestBedViewEngine().configureTestingModule(moduleDef);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     * @return {?}\n     */\n    static compileComponents() { return getTestBed().compileComponents(); }\n    /**\n     * @param {?} ngModule\n     * @param {?} override\n     * @return {?}\n     */\n    static overrideModule(ngModule, override) {\n        _getTestBedViewEngine().overrideModule(ngModule, override);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * @param {?} component\n     * @param {?} override\n     * @return {?}\n     */\n    static overrideComponent(component, override) {\n        _getTestBedViewEngine().overrideComponent(component, override);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * @param {?} directive\n     * @param {?} override\n     * @return {?}\n     */\n    static overrideDirective(directive, override) {\n        _getTestBedViewEngine().overrideDirective(directive, override);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * @param {?} pipe\n     * @param {?} override\n     * @return {?}\n     */\n    static overridePipe(pipe, override) {\n        _getTestBedViewEngine().overridePipe(pipe, override);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @return {?}\n     */\n    static overrideTemplate(component, template) {\n        _getTestBedViewEngine().overrideComponent(component, { set: { template, templateUrl: (/** @type {?} */ (null)) } });\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     * @param {?} component\n     * @param {?} template\n     * @return {?}\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * @param {?} token\n     * @param {?} provider\n     * @return {?}\n     */\n    static overrideProvider(token, provider) {\n        _getTestBedViewEngine().overrideProvider(token, (/** @type {?} */ (provider)));\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n    }\n    /**\n     * @template T\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    static inject(token, notFoundValue, flags) {\n        return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n    /**\n     * @deprecated from v9.0.0 use TestBed.inject\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n    /**\n     * @template T\n     * @param {?} component\n     * @return {?}\n     */\n    static createComponent(component) {\n        return _getTestBedViewEngine().createComponent(component);\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '\\@angular/<platform_name>/testing'.\n     * @param {?} ngModule\n     * @param {?} platform\n     * @param {?=} aotSummaries\n     * @return {?}\n     */\n    initTestEnvironment(ngModule, platform, aotSummaries) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        this.platform = platform;\n        this.ngModule = ngModule;\n        if (aotSummaries) {\n            this._testEnvAotSummaries = aotSummaries;\n        }\n    }\n    /**\n     * Reset the providers for the test injector.\n     * @return {?}\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this.platform = (/** @type {?} */ (null));\n        this.ngModule = (/** @type {?} */ (null));\n        this._testEnvAotSummaries = (/**\n         * @return {?}\n         */\n        () => []);\n    }\n    /**\n     * @return {?}\n     */\n    resetTestingModule() {\n        ɵclearOverrides();\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._compiler = (/** @type {?} */ (null));\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this._moduleRef = (/** @type {?} */ (null));\n        this._moduleFactory = (/** @type {?} */ (null));\n        this._compilerOptions = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._instantiated = false;\n        this._activeFixtures.forEach((/**\n         * @param {?} fixture\n         * @return {?}\n         */\n        (fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        }));\n        this._activeFixtures = [];\n    }\n    /**\n     * @param {?} config\n     * @return {?}\n     */\n    configureCompiler(config) {\n        this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n        this._compilerOptions.push(config);\n    }\n    /**\n     * @param {?} moduleDef\n     * @return {?}\n     */\n    configureTestingModule(moduleDef) {\n        this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        if (moduleDef.providers) {\n            this._providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.declarations) {\n            this._declarations.push(...moduleDef.declarations);\n        }\n        if (moduleDef.imports) {\n            this._imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.schemas) {\n            this._schemas.push(...moduleDef.schemas);\n        }\n        if (moduleDef.aotSummaries) {\n            this._aotSummaries.push(moduleDef.aotSummaries);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    compileComponents() {\n        if (this._moduleFactory || this._instantiated) {\n            return Promise.resolve(null);\n        }\n        /** @type {?} */\n        const moduleType = this._createCompilerAndModule();\n        return this._compiler.compileModuleAndAllComponentsAsync(moduleType)\n            .then((/**\n         * @param {?} moduleAndComponentFactories\n         * @return {?}\n         */\n        (moduleAndComponentFactories) => {\n            this._moduleFactory = moduleAndComponentFactories.ngModuleFactory;\n        }));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _initIfNeeded() {\n        if (this._instantiated) {\n            return;\n        }\n        if (!this._moduleFactory) {\n            try {\n                /** @type {?} */\n                const moduleType = this._createCompilerAndModule();\n                this._moduleFactory =\n                    this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n            }\n            catch (e) {\n                /** @type {?} */\n                const errorCompType = this._compiler.getComponentFromError(e);\n                if (errorCompType) {\n                    throw new Error(`This test module uses the component ${ɵstringify(errorCompType)} which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled. ` +\n                        `Please call \"TestBed.compileComponents\" before your test.`);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        for (const { component, templateOf } of this._templateOverrides) {\n            /** @type {?} */\n            const compFactory = this._compiler.getComponentFactory(templateOf);\n            ɵoverrideComponentView(component, compFactory);\n        }\n        /** @type {?} */\n        const ngZone = new NgZone({ enableLongStackTrace: true, shouldCoalesceEventChangeDetection: false });\n        /** @type {?} */\n        const providers = [{ provide: NgZone, useValue: ngZone }];\n        /** @type {?} */\n        const ngZoneInjector = Injector.create({\n            providers: providers,\n            parent: this.platform.injector,\n            name: this._moduleFactory.moduleType.name\n        });\n        this._moduleRef = this._moduleFactory.create(ngZoneInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n        // before accessing it.\n        ((/** @type {?} */ (this._moduleRef.injector.get(ApplicationInitStatus)))).runInitializers();\n        this._instantiated = true;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _createCompilerAndModule() {\n        /** @type {?} */\n        const providers = this._providers.concat([{ provide: TestBed, useValue: this }]);\n        /** @type {?} */\n        const declarations = [...this._declarations, ...this._templateOverrides.map((/**\n             * @param {?} entry\n             * @return {?}\n             */\n            entry => entry.templateOf))];\n        /** @type {?} */\n        const rootScopeImports = [];\n        /** @type {?} */\n        const rootProviderOverrides = this._rootProviderOverrides;\n        if (this._isRoot) {\n            class RootScopeModule {\n            }\n            RootScopeModule.decorators = [\n                { type: NgModule, args: [{\n                            providers: [\n                                ...rootProviderOverrides,\n                            ],\n                            jit: true,\n                        },] },\n            ];\n            rootScopeImports.push(RootScopeModule);\n        }\n        providers.push({ provide: ɵINJECTOR_SCOPE, useValue: this._isRoot ? 'root' : null });\n        /** @type {?} */\n        const imports = [rootScopeImports, this.ngModule, this._imports];\n        /** @type {?} */\n        const schemas = this._schemas;\n        class DynamicTestModule {\n        }\n        DynamicTestModule.decorators = [\n            { type: NgModule, args: [{ providers, declarations, imports, schemas, jit: true },] },\n        ];\n        /** @type {?} */\n        const compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n        this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n        for (const summary of [this._testEnvAotSummaries, ...this._aotSummaries]) {\n            this._compiler.loadAotSummaries(summary);\n        }\n        this._moduleOverrides.forEach((/**\n         * @param {?} entry\n         * @return {?}\n         */\n        (entry) => this._compiler.overrideModule(entry[0], entry[1])));\n        this._componentOverrides.forEach((/**\n         * @param {?} entry\n         * @return {?}\n         */\n        (entry) => this._compiler.overrideComponent(entry[0], entry[1])));\n        this._directiveOverrides.forEach((/**\n         * @param {?} entry\n         * @return {?}\n         */\n        (entry) => this._compiler.overrideDirective(entry[0], entry[1])));\n        this._pipeOverrides.forEach((/**\n         * @param {?} entry\n         * @return {?}\n         */\n        (entry) => this._compiler.overridePipe(entry[0], entry[1])));\n        return DynamicTestModule;\n    }\n    /**\n     * @private\n     * @param {?} methodName\n     * @param {?} methodDescription\n     * @return {?}\n     */\n    _assertNotInstantiated(methodName, methodDescription) {\n        if (this._instantiated) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * @template T\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    inject(token, notFoundValue, flags) {\n        this._initIfNeeded();\n        if ((/** @type {?} */ (token)) === TestBed) {\n            return (/** @type {?} */ (this));\n        }\n        // Tests can inject things from the ng module and from the compiler,\n        // but the ng module can't inject things from the compiler and vice versa.\n        /** @type {?} */\n        const UNDEFINED = {};\n        /** @type {?} */\n        const result = this._moduleRef.injector.get(token, UNDEFINED, flags);\n        return result === UNDEFINED ? (/** @type {?} */ (this._compiler.injector.get(token, notFoundValue, flags))) :\n            result;\n    }\n    /**\n     * @deprecated from v9.0.0 use TestBed.inject\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    /**\n     * @param {?} tokens\n     * @param {?} fn\n     * @param {?=} context\n     * @return {?}\n     */\n    execute(tokens, fn, context) {\n        this._initIfNeeded();\n        /** @type {?} */\n        const params = tokens.map((/**\n         * @param {?} t\n         * @return {?}\n         */\n        t => this.inject(t)));\n        return fn.apply(context, params);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} override\n     * @return {?}\n     */\n    overrideModule(ngModule, override) {\n        this._assertNotInstantiated('overrideModule', 'override module metadata');\n        this._moduleOverrides.push([ngModule, override]);\n    }\n    /**\n     * @param {?} component\n     * @param {?} override\n     * @return {?}\n     */\n    overrideComponent(component, override) {\n        this._assertNotInstantiated('overrideComponent', 'override component metadata');\n        this._componentOverrides.push([component, override]);\n    }\n    /**\n     * @param {?} directive\n     * @param {?} override\n     * @return {?}\n     */\n    overrideDirective(directive, override) {\n        this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this._directiveOverrides.push([directive, override]);\n    }\n    /**\n     * @param {?} pipe\n     * @param {?} override\n     * @return {?}\n     */\n    overridePipe(pipe, override) {\n        this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this._pipeOverrides.push([pipe, override]);\n    }\n    /**\n     * @param {?} token\n     * @param {?} provider\n     * @return {?}\n     */\n    overrideProvider(token, provider) {\n        this.overrideProviderImpl(token, provider);\n    }\n    /**\n     * @private\n     * @param {?} token\n     * @param {?} provider\n     * @param {?=} deprecated\n     * @return {?}\n     */\n    overrideProviderImpl(token, provider, deprecated = false) {\n        /** @type {?} */\n        let def = null;\n        if (typeof token !== 'string' && (def = ɵgetInjectableDef(token)) && def.providedIn === 'root') {\n            if (provider.useFactory) {\n                this._rootProviderOverrides.push({ provide: token, useFactory: provider.useFactory, deps: provider.deps || [] });\n            }\n            else {\n                this._rootProviderOverrides.push({ provide: token, useValue: provider.useValue });\n            }\n        }\n        /** @type {?} */\n        let flags = 0;\n        /** @type {?} */\n        let value;\n        if (provider.useFactory) {\n            flags |= 1024 /* TypeFactoryProvider */;\n            value = provider.useFactory;\n        }\n        else {\n            flags |= 256 /* TypeValueProvider */;\n            value = provider.useValue;\n        }\n        /** @type {?} */\n        const deps = (provider.deps || []).map((/**\n         * @param {?} dep\n         * @return {?}\n         */\n        (dep) => {\n            /** @type {?} */\n            let depFlags = 0 /* None */;\n            /** @type {?} */\n            let depToken;\n            if (Array.isArray(dep)) {\n                dep.forEach((/**\n                 * @param {?} entry\n                 * @return {?}\n                 */\n                (entry) => {\n                    if (entry instanceof Optional) {\n                        depFlags |= 2 /* Optional */;\n                    }\n                    else if (entry instanceof SkipSelf) {\n                        depFlags |= 1 /* SkipSelf */;\n                    }\n                    else {\n                        depToken = entry;\n                    }\n                }));\n            }\n            else {\n                depToken = dep;\n            }\n            return [depFlags, depToken];\n        }));\n        ɵoverrideProvider({ token, flags, deps, value, deprecatedBehavior: deprecated });\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @return {?}\n     */\n    overrideTemplateUsingTestingModule(component, template) {\n        this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n        class OverrideComponent {\n        }\n        OverrideComponent.decorators = [\n            { type: Component, args: [{ selector: 'empty', template, jit: true },] },\n        ];\n        this._templateOverrides.push({ component, templateOf: OverrideComponent });\n    }\n    /**\n     * @template T\n     * @param {?} component\n     * @return {?}\n     */\n    createComponent(component) {\n        this._initIfNeeded();\n        /** @type {?} */\n        const componentFactory = this._compiler.getComponentFactory(component);\n        if (!componentFactory) {\n            throw new Error(`Cannot create the component ${ɵstringify(component)} as it was not imported into the testing module!`);\n        }\n        // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n        /** @type {?} */\n        const noNgZone = this.inject((/** @type {?} */ (ComponentFixtureNoNgZone)), false);\n        // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n        /** @type {?} */\n        const autoDetect = this.inject((/** @type {?} */ (ComponentFixtureAutoDetect)), false);\n        /** @type {?} */\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        /** @type {?} */\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        /** @type {?} */\n        const rootElId = `root${_nextRootElementId$1++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        /** @type {?} */\n        const initComponent = (/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this._moduleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        });\n        /** @type {?} */\n        const fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._instantiated;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._compiler;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._moduleRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._moduleFactory;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._compilerOptions;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._moduleOverrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._componentOverrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._directiveOverrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._pipeOverrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._providers;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._declarations;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._imports;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._schemas;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._activeFixtures;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._testEnvAotSummaries;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._aotSummaries;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._templateOverrides;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._isRoot;\n    /**\n     * @type {?}\n     * @private\n     */\n    TestBedViewEngine.prototype._rootProviderOverrides;\n    /** @type {?} */\n    TestBedViewEngine.prototype.platform;\n    /** @type {?} */\n    TestBedViewEngine.prototype.ngModule;\n}\n/**\n * \\@description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * \\@publicApi\n * @type {?}\n */\nconst TestBed = ɵivyEnabled ? (/** @type {?} */ ((/** @type {?} */ (TestBedRender3)))) : (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * \\@publicApi\n * @type {?}\n */\nconst getTestBed = ɵivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\n/** @type {?} */\nlet testBed$1;\n/**\n * @return {?}\n */\nfunction _getTestBedViewEngine() {\n    return testBed$1 = testBed$1 || new TestBedViewEngine();\n}\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * Notes:\n * - inject is currently a function because of some Traceur limitation the syntax should\n * eventually\n *   becomes `it('...', \\@Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\n *\n * \\@publicApi\n * @param {?} tokens\n * @param {?} fn\n * @return {?}\n */\nfunction inject(tokens, fn) {\n    /** @type {?} */\n    const testBed = getTestBed();\n    if (tokens.indexOf(AsyncTestCompleter) >= 0) {\n        // Not using an arrow function to preserve context passed from call site\n        return (/**\n         * @this {?}\n         * @return {?}\n         */\n        function () {\n            // Return an async test method that returns a Promise if AsyncTestCompleter is one of\n            // the injected tokens.\n            return testBed.compileComponents().then((/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const completer = testBed.inject(AsyncTestCompleter);\n                testBed.execute(tokens, fn, this);\n                return completer.promise;\n            }));\n        });\n    }\n    else {\n        // Not using an arrow function to preserve context passed from call site\n        return (/**\n         * @this {?}\n         * @return {?}\n         */\n        function () { return testBed.execute(tokens, fn, this); });\n    }\n}\n/**\n * \\@publicApi\n */\nclass InjectSetupWrapper {\n    /**\n     * @param {?} _moduleDef\n     */\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _addModule() {\n        /** @type {?} */\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            getTestBed().configureTestingModule(moduleDef);\n        }\n    }\n    /**\n     * @param {?} tokens\n     * @param {?} fn\n     * @return {?}\n     */\n    inject(tokens, fn) {\n        /** @type {?} */\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return (/**\n         * @this {?}\n         * @return {?}\n         */\n        function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        });\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    InjectSetupWrapper.prototype._moduleDef;\n}\n/**\n * @param {?} moduleDef\n * @param {?=} fn\n * @return {?}\n */\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return (/**\n         * @this {?}\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            const testBed = getTestBed();\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        });\n    }\n    return new InjectSetupWrapper((/**\n     * @return {?}\n     */\n    () => moduleDef));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/before_each.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst _global$1 = (/** @type {?} */ ((typeof window === 'undefined' ? global : window)));\n// Reset the test providers and the fake async zone before each test.\nif (_global$1.beforeEach) {\n    _global$1.beforeEach((/**\n     * @return {?}\n     */\n    () => {\n        TestBed.resetTestingModule();\n        resetFakeAsyncZone();\n    }));\n}\n// TODO(juliemr): remove this, only used because we need to export something to have compilation\n// work.\n/** @type {?} */\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/metadata_override.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/private_export_testing.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/src/testing.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/core/testing/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, withModule, MetadataOverrider as ɵMetadataOverrider, TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory, TestBedViewEngine as ɵangular_packages_core_testing_testing_a, TestBedRender3 as ɵangular_packages_core_testing_testing_b, _getTestBedRender3 as ɵangular_packages_core_testing_testing_c };\n\n//# sourceMappingURL=testing.js.map"],"sourceRoot":"webpack:///"}